# ПОЛНЫЙ АНАЛИЗ МЕХАНИК ИГРЫ TANABATA
## Детальное описание всех игровых систем и механик

---

## СОДЕРЖАНИЕ

1. [ГЛОБАЛЬНАЯ АРХИТЕКТУРА](#глобальная-архитектура)
2. [ГЕКСАГОНАЛЬНАЯ КАРТА](#гексагональная-карта)
3. [СИСТЕМА ЭНЕРГОСЕТИ](#система-энергосети)
4. [СИСТЕМА ГЕНЕРАЦИИ РУДЫ](#система-генерации-руды)
5. [СИСТЕМА ВОЛН И ВРАГОВ](#система-волн-и-врагов)
6. [СИСТЕМА БОЯ И БАШЕН](#система-боя-и-башен)
7. [СИСТЕМА СНАРЯДОВ](#система-снарядов)
8. [СИСТЕМА КРАФТА](#система-крафта)
9. [СИСТЕМА СТАТУС-ЭФФЕКТОВ](#система-статус-эффектов)
10. [СИСТЕМА АУР](#система-аур)
11. [СПЕЦИАЛИЗИРОВАННЫЕ БАШНИ](#специализированные-башни)
12. [СИСТЕМА ОПЫТА И ПРОГРЕССИИ](#система-опыта-и-прогрессии)
13. [СИСТЕМА ФАЗ ИГРЫ](#система-фаз-игры)
14. [UI И ВИЗУАЛИЗАЦИЯ](#ui-и-визуализация)
15. [МЕЛКИЕ МЕХАНИКИ И ТОНКОСТИ](#мелкие-механики-и-тонкости)

---

## 1. ГЛОБАЛЬНАЯ АРХИТЕКТУРА

### ECS (Entity-Component-System)
Игра построена на чистой ECS архитектуре:
- **Entities**: ID-идентификаторы (просто числа)
- **Components**: Данные (структуры в мапах)
- **Systems**: Логика (обработчики компонентов)

### Список всех компонентов:
- `Position` - позиция в пиксельных координатах
- `Velocity` - скорость движения
- `Path` - путь для врагов (гексы)
- `Health` - здоровье
- `Renderable` - визуальные параметры (цвет, радиус)
- `Tower` - данные башни (DefID, Level, Hex, IsActive)
- `Projectile` - снаряд
- `Combat` - боевые параметры
- `Ore` - руда
- `Enemy` - враг
- `LineRender` - линия энергосети
- `Text` - текстовый элемент
- `DamageFlash` - вспышка при уроне
- `AoeEffect` - AOE эффект
- `Aura` - аура башни
- `AuraEffect` - эффект ауры на башне
- `SlowEffect` - замедление
- `PoisonEffect` - яд
- `JadePoisonContainer` - стакающийся яд от Jade башни
- `Laser` - лазерный луч
- `VolcanoEffect` - визуальный эффект вулкана
- `VolcanoAura` - логика атаки вулкана
- `Combinable` - возможные комбинации крафта
- `ManualSelectionMarker` - маркер ручного выбора
- `PlayerStateComponent` - состояние игрока (уровень, опыт, здоровье)
- `Beacon` - маяк (вращающийся луч)
- `BeaconAttackSector` - сектор атаки маяка
- `TurretComponent` - турель с наведением
- `Wave` - волна врагов
- `GameState` - глобальное состояние игры

### State Machine
Игра имеет 3 состояния:
1. **MenuState** - главное меню
2. **GameState** - игровой процесс
3. **PauseState** - пауза

### Event System
Система событий для loose coupling:
- `EnemyKilled` - враг убит
- `TowerPlaced` - башня размещена
- `TowerRemoved` - башня удалена
- `OreDepleted` - руда истощена
- `WaveEnded` - волна закончена
- `OreConsumed` - руда потрачена
- `CombineTowersRequest` - запрос на крафт
- `ToggleTowerSelectionForSaveRequest` - выбор башни для сохранения
- `EnemyRemovedFromGame` - враг удален из игры

---

## 2. ГЕКСАГОНАЛЬНАЯ КАРТА

### Система координат
**Осевые координаты (Axial)**: `(Q, R)`
- Pointy-top ориентация (острые вершины вверх/вниз)
- Математика: `S = -Q - R` (кубическая координата)

### Преобразование координат
```
PixelX = HexSize * (√3*Q + √3/2*R)
PixelY = HexSize * (3/2 * R)
```

### Расстояние между гексами
```
Distance = (|Q1-Q2| + |R1-R2| + |Q1+R1-Q2-R2|) / 2
```

### Генерация карты
**Процедурная генерация в 7 этапов:**

1. **Базовая гексагональная сетка**
   - Радиус: 15 гексов
   - Все тайлы проходимы изначально

2. **Установка Entry/Exit**
   - Entry: левая сторона `(-16, 8)`
   - Exit: правая сторона `(16, -8)`

3. **Генерация 6 чекпоинтов**
   - Размещаются на расстоянии `Radius - 3 = 12` от центра
   - 6 направлений (по одному на каждую сторону шестиугольника)
   - Порядок случайный (циклически перемешивается)

4. **Процедурное добавление/удаление секций**
   - Граница делится на секции по 3 гекса
   - 30% шанс добавить внешний слой
   - 30% шанс удалить внутренний слой
   - Проверка: путь Entry→Exit должен существовать

5. **Обработка углов**
   - 30% шанс добавить угловые выступы
   - 30% шанс удалить углы

6. **Постобработка**
   - Удаление изолированных гексов (< 2 соседей)
   - Добавление гексов, окруженных >= 4 соседями
   - Итеративно до стабилизации

7. **Зоны исключения**
   - Радиус 3 вокруг Entry/Exit/Checkpoints
   - В этих зонах модификации запрещены

### Pathfinding (A*)
**Алгоритм A\* для поиска пути:**
- Эвристика: манхэттенское расстояние в гекс-координатах
- Стоимость перехода: всегда 1
- Проверка проходимости: `tile.Passable == true`
- Путь строится через все чекпоинты последовательно

---

## 3. СИСТЕМА ЭНЕРГОСЕТИ

### Концепция
Башни работают ТОЛЬКО если соединены с рудой через сеть линий.

### Типы башен в сети:
- **Miner (Шахтер)** - добывает энергию из руды
- **Wall (Стена)** - НЕ участвует в сети
- **Attack (Атакующие)** - требуют энергию

### Правила соединения:

**1. Обычные башни (Attack, Wall):**
- Соединяются только с соседями на расстоянии 1 гекс

**2. Башни-шахтеры (Miner):**
- Соединяются с соседями на расстоянии 1 гекс
- **СПЕЦИАЛЬНОЕ ПРАВИЛО**: Соединяются с другими Miner'ами на расстоянии до 3 гексов, если:
  - Находятся на одной прямой линии (`IsOnSameLine`)
  - Между ними нет других Miner'ов

### Алгоритм построения сети (MST - Minimum Spanning Tree)

**Алгоритм Крускала:**

1. **Сбор всех возможных ребер**
   - Для каждой пары башен проверяется, могут ли они соединиться
   - Создается `energyEdge{Tower1ID, Tower2ID, Type1, Type2, Distance}`

2. **Сортировка ребер по приоритету**
   - Miner-Miner: вес = `100 + distance`
   - Miner-Attacker: вес = `200 + distance`
   - Attacker-Attacker: вес = `300 + distance`

3. **Union-Find для предотвращения циклов**
   - Добавляем ребро только если башни в разных компонентах связности
   - После добавления делаем Union

4. **Активация башен**
   - BFS от всех Miner'ов на руде
   - Отмечаем все достижимые башни как активные

### Инкрементальное добавление башни

**Оптимизация**: При добавлении новой башни не пересчитываем всю сеть.

**Алгоритм:**

1. **Проверка на корень**
   - Если новая башня - Miner на руде → она активна сразу

2. **Поиск соединений с активными башнями**
   - Ищем все возможные соединения с УЖЕ активными башнями
   - Сортируем по приоритету

3. **Предотвращение треугольников**
   - Перед соединением проверяем: `formsTriangle(id1, id2)`
   - Если создается 3-цикл, пропускаем это соединение
   - Это эстетическая оптимизация

4. **Особый случай: Интерсепт Miner'а**
   - Если новый Miner ставится на линию между двумя Miner'ами:
     - Удаляем старую линию
     - Создаем две новые (через новый Miner)

5. **Расширение сети (BFS)**
   - От новой активной башни запускаем BFS
   - Активируем все достижимые неактивные башни
   - Создаем линии к ним

### Удаление башни

**Сложный алгоритм переподключения:**

1. **Поиск осиротевших башен**
   - BFS от всех Miner'ов на руде
   - Помечаем все достижимые как powered
   - Остальные - orphaned

2. **Объединение активных сетей**
   - Если есть несколько disconnected активных сетей, соединяем их
   - Используем Union-Find для проверки компонент

3. **Итеративное переподключение**
   - Цикл:
     - Находим все возможные мосты (active → inactive)
     - Сортируем по приоритету
     - Строим ОДИН лучший мост
     - Пересчитываем powered towers заново
   - Повторяем, пока есть доступные мосты

4. **Очистка**
   - Удаляем линии к неактивным башням

### Деградация энергии

**Чем длиннее путь от руды, тем слабее урон:**

```
Multiplier = LineDegradationFactor ^ AttackerCount
```

Где:
- `LineDegradationFactor = 0.9`
- `AttackerCount` - количество атакующих башен в пути от руды

**Расчет пути:**
- BFS от башни к ближайшему Miner'у на руде
- Подсчитываем только Attack башни (игнорируем Miner и Wall)

---

## 4. СИСТЕМА ГЕНЕРАЦИИ РУДЫ

### Концепция
Карта содержит 3 жилы руды разной силы:
1. **Центральная** - слабая, близко к центру
2. **Средняя** - средняя сила, средний радиус
3. **Дальняя** - самая сильная, далеко от центра

### Алгоритм генерации

**Шаг 1: Выбор центров жил**

1. **Центральная жила** (дистанция < 3 от центра)
   - Случайный гекс рядом с центром
   - Проверка: не слишком близко к Entry/Exit/Checkpoints

2. **Средняя жила** (дистанция 4-9)
   - Случайный гекс
   - Минимум 6 гексов от центральной

3. **Дальняя жила** (дистанция >= 10)
   - Выбирается самый далекий от первых двух
   - Алгоритм: `findFarthestHex` максимизирует сумму расстояний

**Шаг 2: Формирование жил**

1. **Центральная жила (детерминированная)**
   - Ровно 4 гекса
   - Центр + 3 случайных соседа

2. **Средняя и дальняя жилы (процедурные)**
   - `GetHexesInRange(center, radius=2)`
   - Все гексы в радиусе 2 от центра

**Шаг 3: Распределение энергии**

**Общая энергия карты:**
```
TotalMapPower = 240 + rand(0, 30) = 240-270
```

**Доли жил:**
```
CentralShare = (18% + rand(0,4%)) * (2.5/1.5) ≈ 30-37%
MidShare = 27% + rand(0,6%) = 27-33%
FarShare = остаток = 33-43%
```

**Распределение внутри жилы:**

1. **Центральная (детерминированное)**
   - TotalPower делится между 4 гексами
   - Каждый гекс получает случайную долю с колебанием ±40%
   - Последний гекс получает остаток

2. **Средняя и дальняя (процедурное через кружки)**
   - Генерируются круги со случайными центрами внутри жилы
   - Каждый круг имеет мощность 5-20% от оставшейся энергии
   - Радиус круга: `HexSize * 0.2 * (power/5)`
   - Гексы, попадающие в круг, получают его энергию

**Шаг 4: Создание компонентов**

Для каждого гекса с энергией создается:
```
Ore Component:
  Power: 0.0-3.0 (энергия в процентах)
  MaxReserve: Power * 100
  CurrentReserve: Power * 100
  Hex: гекс руды
  Position: пиксельные координаты
  Radius: HexSize * 0.2 + Power * HexSize
  Color: синий (0,0,255,128)
  PulseRate: 2.0
```

Плюс текстовый компонент с процентами.

### Истощение руды

- Каждый выстрел башни тратит `ShotCost` из `CurrentReserve`
- Руда считается истощенной при `CurrentReserve < 0.1`
- При истощении отправляется событие `OreDepleted`
- Башни на истощенной руде деактивируются

### Бонус от количества руды

**Множитель урона зависит от запаса:**

```
if Reserve <= 100:  Multiplier = 1.5
if Reserve >= 1000: Multiplier = 0.75
Между: линейная интерполяция
```

Формула:
```
Mult = (Reserve - 100) * (0.75 - 1.5) / (1000 - 100) + 1.5
```

---

## 5. СИСТЕМА ВОЛН И ВРАГОВ

### Паттерны волн

**10 предопределенных волн:**

| Волна | Враг | Кол-во | Интервал (мс) |
|-------|------|--------|---------------|
| 1 | ENEMY_NORMAL_WEAK | 5 | 800 |
| 2 | ENEMY_NORMAL_WEAK | 7 | 800 |
| 3 | ENEMY_NORMAL_WEAK | 9 | 800 |
| 4 | ENEMY_TOUGH | 7 | 1000 |
| 5 | ENEMY_NORMAL | 10 | 800 |
| 6 | ENEMY_MAGIC_RESIST | 10 | 750 |
| 7 | ENEMY_PHYSICAL_RESIST | 10 | 750 |
| 8 | ENEMY_FAST | 15 | 500 |
| 9 | ENEMY_NORMAL | 20 | 400 |
| 10 | ENEMY_BOSS | 1 | 1000 |

**После волны 10:** циклическое повторение волн 6-10

### Типы врагов

| ID | HP | Скорость | Физ. броня | Маг. броня | Особенность |
|----|----|---------|-----------|-----------|----|
| NORMAL_WEAK | 35 | 80 | 5 | 0 | Слабый |
| NORMAL | 115 | 80 | 10 | 5 | Обычный |
| TOUGH | 280 | 75 | 25 | 15 | Крепкий |
| MAGIC_RESIST | 240 | 80 | -20 | 80 | Магический щит |
| PHYSICAL_RESIST | 240 | 80 | 80 | -20 | Физический щит |
| FAST | 140 | 160 | 5 | 10 | Быстрый |
| BOSS | 6000 | 60 | 40 | 40 | Босс |

### Система урона врагов

**Каждый враг несет урон игроку:**
- Общий урон волны: **100 единиц**
- Распределение: равномерно между всеми врагами + остаток
- Алгоритм:
  1. `baseDamage = 100 / enemyCount`
  2. `remainder = 100 % enemyCount`
  3. Раздаем по `baseDamage` всем
  4. Остаток раздаем случайно через `PRNG`
  5. Перемешиваем список уронов

**Нанесение урона:**
- Когда враг достигает Exit, наносится его урон
- В God Mode урон не наносится
- Урон вычитается из `PlayerState.Health`
- При Health <= 0 - Game Over

### Система чекпоинтов

**Динамическая подсветка:**
- Враги должны пройти через ВСЕ чекпоинты последовательно
- Система отслеживает `LastCheckpointIndex` для каждого врага
- **Механика подсветки:**
  - Находится ПОСЛЕДНИЙ (физически) живой враг
  - Это враг с наименьшим `Path.CurrentIndex`
  - Подсвечиваются все чекпоинты от 0 до его `LastCheckpointIndex`
  - При смерти последнего врага подсветка исчезает

**Расчет пути:**
- Entry → Checkpoint1 → ... → CheckpointN → Exit
- Каждый сегмент рассчитывается через A*
- Путь пересчитывается при размещении/удалении стен

### Спавн врагов

**Процесс:**
1. Система `WaveSystem` создает компонент `Wave`:
   - `EnemiesToSpawn` - сколько осталось
   - `SpawnInterval` - интервал в секундах
   - `SpawnTimer` - текущий таймер
   - `CurrentPath` - расчитанный путь
   - `DamagePerEnemy` - список уронов

2. Каждый Update:
   - `SpawnTimer += deltaTime`
   - Если `SpawnTimer >= SpawnInterval`:
     - Создаем врага
     - `EnemiesToSpawn--`
     - `SpawnTimer = 0`

3. Волна завершена когда:
   - `EnemiesToSpawn == 0` И `activeEnemies == 0`

### Движение врагов

**Алгоритм:**
1. Берем текущий target hex из `Path.Hexes[CurrentIndex]`
2. Рассчитываем направление и расстояние до него
3. **Учет замедлений:**
   - `SlowEffect.SlowFactor` (обычное замедление)
   - `JadePoisonContainer` (суммарное замедление от стаков)
4. Двигаем врага на `speed * deltaTime * slowFactors`
5. При достижении гекса: `CurrentIndex++`
6. Проверяем, не чекпоинт ли это
7. Если достигли конца пути → наносим урон игроку

---

## 6. СИСТЕМА БОЯ И БАШЕН

### Типы башен

**Базовые атакующие (Level 1):**
- **TA** (Физическая) - 25 урона, 1.0 атк/с, 0.06 cost
- **TE** (Магическая) - 25 урона, 1.0 атк/с, 0.07 cost
- **TO** (Чистая) - 20 урона, 1.0 атк/с, 0.04 cost
- **PA** (Сплит-физ.) - 18 урона, 2 снаряда, 0.08 cost
- **PE** (Сплит-маг.) - 18 урона, 2 снаряда, 0.06 cost
- **PO** (Сплит-чист.) - 15 урона, 2 снаряда, 0.10 cost

**Специальные (Level 1):**
- **DE** (Аура) - 0 урона, ускоряет соседей x2.0
- **NI** (Замедление) - 1 урона, 1.67 атк/с, замедляет
- **NU** (Яд) - 1 урона, 0.8 атк/с, яд 10 DPS

**Инфраструктура:**
- **TOWER_MINER** - добыча энергии
- **TOWER_WALL** - блокирует путь

**Крафтовые (Level 2):**
- **TOWER_SILVER** - 55 урона, лазер, физ.
- **TOWER_MALACHITE** - 20 урона, 3 снаряда + impact burst
- **TOWER_VOLCANO** - 40 урона, AOE
- **TOWER_LIGHTHOUSE** - 35 урона, вращающийся луч
- **TOWER_JADE** - 5 урона, стакующийся яд

### Типы атак

**1. PROJECTILE (Снаряд)**
- Создается физический снаряд
- Летит к врагу с учетом предсказания
- При попадании наносит урон + эффекты

**2. LASER (Лазер)**
- Мгновенное попадание
- Находит ближайшую цель
- Создает визуальный луч на 0.15 сек
- Урон применяется сразу

**3. AOE (Area of Effect)**
- Не используется напрямую в CombatSystem
- Реализовано через VolcanoSystem

**4. BEACON (Маяк)**
- Не используется напрямую в CombatSystem
- Реализовано через BeaconSystem

**5. NONE (Специальные)**
- Вулкан и Маяк используют свои системы

### Типы урона и броня

**Типы урона:**
- **PHYSICAL** - уменьшается физ. броней
- **MAGICAL** - уменьшается маг. броней
- **PURE** - игнорирует броню
- **SLOW** - урон + замедление
- **POISON** - урон + яд (DOT)
- **INTERNAL** - специальный (для DE башни)

**Формула урона:**
```
switch damageType:
  PHYSICAL: finalDamage = max(damage - physicalArmor, 0)
  MAGICAL:  finalDamage = max(damage - magicalArmor, 0)
  PURE:     finalDamage = damage
```

### Система турелей (TA башня)

**TurretComponent:**
```
CurrentAngle: текущий угол поворота (yaw)
TargetAngle: целевой угол
CurrentPitch: текущий наклон (pitch)
TargetPitch: целевой наклон
TurnSpeed: скорость поворота (8.0 рад/с)
AcquisitionRange: дальность захвата цели (1.4 * attackRange)
TargetID: текущая цель
```

**Алгоритм наведения:**

1. **Поиск/проверка цели:**
   - Если есть цель, проверяем её валидность
   - Цель валидна если: жива, в радиусе захвата
   - Если невалидна, ищем новую

2. **Расчет углов:**
   - Предсказываем позицию цели (упреждение)
   - **Горизонтальный угол (yaw):**
     ```
     TargetAngle = atan2(dy, dx)
     ```
   - **Вертикальный угол (pitch):**
     ```
     deltaHeight = targetHeight - turretHeight
     horizontalDist = sqrt(dx² + dy²)
     TargetPitch = atan2(deltaHeight, horizontalDist)
     ```

3. **Плавный поворот:**
   ```
   CurrentAngle = LerpAngle(CurrentAngle, TargetAngle, TurnSpeed * dt)
   CurrentPitch = Lerp(CurrentPitch, TargetPitch, TurnSpeed * dt)
   ```

4. **Синхронизация с атакой:**
   - Стрельба всегда происходит по текущей цели турели
   - Снаряд вылетает из смещенной позиции (спереди башни)

### Цикл атаки

**Для каждой башни каждый кадр:**

1. **Проверки активности:**
   - `Tower.IsActive == true`
   - `Combat.FireCooldown <= 0`

2. **Проверка энергии:**
   - Находим источники энергии через энергосеть
   - Суммируем `CurrentReserve` всех источников
   - Требуется >= `ShotCost`

3. **Поиск цели:**
   - Для турелей: используем текущую цель турели
   - Для остальных: `findTargetsForSplitAttack(hex, range, splitCount)`
   - Сортировка по расстоянию от башни

4. **Расчет урона:**
   ```
   BaseDamage = TowerDef.Combat.Damage
   OreBoost = calculateOreBoostMultiplier(oreReserve)
   Degradation = calculateLineDegradationMultiplier(pathToOre)
   FinalDamage = BaseDamage * OreBoost * Degradation
   ```

5. **Создание снарядов/урон:**
   - PROJECTILE: создаем снаряд для каждой цели
   - LASER: мгновенно применяем урон + визуал

6. **Трата энергии:**
   - Выбираем случайный источник энергии
   - Отправляем событие `OreConsumed` с `{SourceID, Amount}`
   - `OreSystem` обрабатывает событие и вычитает

7. **Кулдаун:**
   ```
   FireRate = Combat.FireRate
   if AuraEffect exists:
     FireRate *= AuraEffect.SpeedMultiplier
   Combat.FireCooldown = 1.0 / FireRate
   ```

### Loot Tables (Дроп башен)

**Система уровней игрока:**
- При размещении башни берется `PlayerState.Level`
- Выбирается соответствующая `LootTable`
- Если для уровня нет таблицы, берется ближайшая меньшая

**Loot Table структура:**
```json
{
  "player_level": 1,
  "entries": [
    {"tower_id": "TA", "weight": 10},
    {"tower_id": "TE", "weight": 10},
    ...
  ]
}
```

**Взвешенный выбор:**
- Суммируются все веса
- Генерируется случайное число от 0 до суммы
- Выбирается башня, в чей диапазон попало число

**Специальные правила:**
- Если позиция 0 и волна < 4: всегда TOWER_MINER
- Иначе: через loot table

---

## 7. СИСТЕМА СНАРЯДОВ

### Компонент Projectile

**Основные поля:**
```
SourceID: ID башни-источника
TargetID: ID цели
Speed: скорость полета
Damage: урон
Direction: направление (радианы)
AttackType: тип урона
```

**Визуальные:**
```
Age: возраст снаряда
ScaleUpDuration: время анимации роста (0.15 сек)
SpawnHeight: начальная высота
VisualType: тип визуала ("ELLIPSE" для Jade)
```

**Эффекты:**
```
SlowsTarget: накладывает замедление
SlowDuration, SlowFactor
AppliesPoison: накладывает яд
PoisonDuration, PoisonDPS
```

**Impact Burst:**
```
ImpactBurstRadius: радиус взрыва
ImpactBurstTargetCount: макс. целей
ImpactBurstDamageFactor: множитель урона (обычно 0.4)
```

**Условное самонаведение:**
```
IsConditionallyHoming: перенацеливается при замедлении цели
TargetLastSlowFactor: последний фактор замедления цели
```

### Жизненный цикл снаряда

**1. Создание:**
- `CombatSystem.CreateProjectile()`
- Предсказываем позицию цели
- Устанавливаем начальное направление
- Определяем начальную высоту:
  - Для турелей: высота турели
  - Для остальных: 0 (низкая)

**2. Полет:**
- Каждый кадр: `pos += direction * speed * dt`
- **Условное самонаведение:**
  - Если `SlowFactor` цели изменился
  - Пересчитываем направление к предсказанной позиции

**3. Попадание:**
- Проверка расстояния: `dist <= speed*dt || dist < 15`
- Применяем эффекты и урон
- Impact Burst (если есть)
- Удаляем снаряд

### Предсказание позиции цели

**Итеративный алгоритм:**

```
timeToHit = 0
for 5 iterations:
  predictedPos = simulateEnemyMovement(enemy, timeToHit)
  distance = distance(towerPos, predictedPos)
  newTimeToHit = distance / projectileSpeed
  if |newTimeToHit - timeToHit| < 0.01:
    break
  timeToHit = newTimeToHit
```

**Симуляция движения:**
- Двигаем врага по его пути
- Учитываем текущую скорость и замедления
- Останавливаем когда время истекло

### Impact Burst (Malachite башня)

**Механика:**

1. При попадании основного снаряда:
   - Находим всех врагов в радиусе `ImpactBurstRadius`
   - Исключаем первичную цель
   - Ограничиваем до `ImpactBurstTargetCount`

2. Для каждой вторичной цели:
   - Создаем мини-снаряд (радиус 0.5x)
   - Урон = основной урон * `ImpactBurstDamageFactor`
   - Важно: мини-снаряд НЕ имеет Impact Burst (предотвращение рекурсии)

3. Мини-снаряды летят из точки попадания

### Визуальные эффекты снарядов

**Анимация роста:**
```
if Age < ScaleUpDuration:
  scale = Age / ScaleUpDuration
else:
  scale = 1.0
```

**Типы визуала:**
- Обычный: сфера
- "ELLIPSE" (Jade): вытянутый эллипсоид по направлению движения

**Цвета по типу урона:**
- PHYSICAL: оранжево-красный
- MAGICAL: пурпурный
- PURE: светло-голубой
- SLOW: голубой
- POISON: желто-зеленый

**Высота полета:**
- Начало: `SpawnHeight`
- Конец: высота цели (радиус рендерабл)
- Интерполяция по прогрессу полета

---

## 8. СИСТЕМА КРАФТА

### Рецепты

**Структура рецепта:**
```json
{
  "inputs": [
    {"id": "TA", "level": 1},
    {"id": "PA", "level": 1},
    {"id": "NI", "level": 1}
  ],
  "output_id": "TOWER_SILVER"
}
```

**Все рецепты:**
1. TA + PA + NI → TOWER_SILVER
2. PA + PE + PO → TOWER_MALACHITE
3. PE + DE + NU → TOWER_VOLCANO
4. TO + DE + PO → TOWER_LIGHTHOUSE
5. TE + NI + NU → TOWER_JADE

### Обнаружение комбинаций

**Алгоритм:**

**1. Группировка башен:**
- Для каждой башни создаем ключ `"ID-Level"`
- Группируем в бакеты: `map[string][]EntityID`

**2. Для каждого рецепта:**
- Составляем требования: `map[string]int` (сколько нужно каждого типа)
- Проверяем достаточность ингредиентов

**3. Генерация комбинаций:**
- Рекурсивно перебираем все возможные наборы башен
- Для каждого типа ингредиента выбираем `requiredCount` башен
- Комбинации сортируются для уникальности

**4. Создание Combinable компонентов:**
- Для каждой найденной комбинации
- Добавляем `CraftInfo` всем участникам
- Каждая башня может участвовать в нескольких комбинациях

### Выполнение крафта

**Процесс:**

1. **Выбор комбинации:**
   - Игрок кликает на башню с `Combinable`
   - Берется первая возможная комбинация

2. **Трансформация центральной башни:**
   - DefID → OutputID
   - CraftingLevel = новый уровень
   - Combat компонент обновляется
   - Aura удаляется (если была)
   - Color меняется

3. **Трансформация остальных башен:**
   - Все остальные башни → TOWER_WALL
   - Combat и Aura удаляются
   - Color = цвет стены

4. **Пересчеты:**
   - `RecalculateCombinations()` - поиск новых комбинаций
   - `RecalculateAuras()` - пересчет аур
   - `rebuildEnergyNetwork()` - перестройка сети

### Ручной выбор башен (Shift+Click)

**Механика:**

1. **Добавление башни:**
   - Shift+LeftClick: добавляет в конец списка
   - Если уже выбрана, перемещает в конец

2. **Удаление башни:**
   - Shift+RightClick: удаляет из списка

3. **Маркер:**
   - `Tower.IsManuallySelected = true`
   - Визуализируется в рендере

4. **Учет в крафте:**
   - Система крафта учитывает только выбранные башни (если выбор не пуст)

---

## 9. СИСТЕМА СТАТУС-ЭФФЕКТОВ

### SlowEffect (Замедление)

**Компонент:**
```
SlowFactor: множитель скорости (0.5 = 50% от нормы)
Timer: оставшееся время эффекта
```

**Применение:**
- NI башня накладывает при попадании снаряда
- Стандартно: `SlowFactor = 0.5`, `Duration = 2.0 сек`

**Эффект:**
```
effectiveSpeed = baseSpeed * SlowFactor
```

**Обновление:**
- `Timer -= deltaTime`
- При Timer <= 0 удаляем компонент

### PoisonEffect (Базовый яд)

**Компонент:**
```
DamagePerSec: урон в секунду
Timer: оставшееся время
TickTimer: таймер до следующего тика (1 сек)
```

**Применение:**
- NU башня накладывает при попадании
- Стандартно: `DPS = 10`, `Duration = 2.0 сек`

**Обновление:**
```
Timer -= deltaTime
TickTimer -= deltaTime
if TickTimer <= 0:
  ApplyDamage(entityID, DamagePerSec, PURE)
  TickTimer = 1.0
```

### JadePoisonContainer (Стакующийся яд)

**Концепция:**
- Каждое попадание Jade снаряда добавляет стак
- Стаки существуют независимо (свои таймеры)
- Урон и замедление СУММИРУЮТСЯ

**Компонент:**
```
Target: ID цели
Instances: []JadePoisonInstance
DamagePerStack: базовый урон (10)
SlowFactorPerStack: базовое замедление (0.05 = 5%)
```

**Инстанс яда:**
```
Duration: оставшееся время (5 сек)
TickTimer: таймер тика (1 сек)
```

**Расчет урона:**
```
stacks = len(Instances)
damage = (DamagePerStack * stacks) * (1.1 ^ (stacks-1))
```

Формула: каждый стак дает +10% урона предыдущим.

**Расчет замедления:**
```
totalSlow = SlowFactorPerStack * stacks
speedMultiplier = 1.0 - totalSlow
if speedMultiplier < 0.1:
  speedMultiplier = 0.1  // минимум 10%
```

**Обновление:**
```
For each instance:
  Duration -= deltaTime
  TickTimer -= deltaTime
  if TickTimer <= 0:
    Calculate damage from all stacks
    Apply damage
    TickTimer = 1.0
  if Duration <= 0:
    Remove this instance

if no instances left:
  Remove container
```

### AuraEffect (Аура ускорения)

**Компонент:**
```
SpeedMultiplier: множитель скорости стрельбы
```

**Применение:**
- Пересчитывается при изменении расположения башен
- DE башня дает x2.0 скорость соседям

**Стакование:**
- Множители перемножаются
- Если 2 DE башни: x2.0 * x2.0 = x4.0

**Эффект:**
```
effectiveFireRate = baseFireRate * SpeedMultiplier
cooldown = 1.0 / effectiveFireRate
```

---

## 10. СИСТЕМА АУР

### Механика

**DE башня** создает ауру радиусом 2 гекса.

### Правила применения

**Кто получает бонус:**
- Attack башни (имеют Combat компонент)
- Исключения: сама DE башня, Miner'ы, Wall'ы

**Условия:**
- DE башня должна быть активна
- Цель в радиусе <= 2 гексов
- Расстояние считается в гекс-координатах

### Пересчет аур

**Когда происходит:**
- При размещении башни
- При удалении башни
- После крафта

**Алгоритм:**

1. **Очистка:**
   - Удаляем все `AuraEffect` компоненты

2. **Для каждой активной DE башни:**
   - Находим все Attack башни в радиусе
   - Для каждой башни:
     ```
     if AuraEffect not exists:
       effect.SpeedMultiplier = 1.0
       create AuraEffect
     effect.SpeedMultiplier *= aura.SpeedMultiplier
     ```

3. **Результат:**
   - Каждая башня получает накопленный множитель
   - Если башня в 2 аурах: x2.0 * x2.0 = x4.0

---

## 11. СПЕЦИАЛИЗИРОВАННЫЕ БАШНИ

### TOWER_VOLCANO (Вулкан)

**Тип атаки:** AOE постоянный урон

**Параметры:**
- Урон: 40 базовый (10 за тик)
- Range: 2 гекса
- Tick rate: 4 тика в секунду
- Shot cost: 0.25 за выстрел (0.0625 за тик)

**Алгоритм:**

**Каждый тик (0.25 сек):**

1. **Проверки:**
   - Башня активна
   - Достаточно энергии для тика

2. **Поиск целей:**
   - Все враги в радиусе 2 гексов
   - Расстояние считается от гекса башни

3. **Нанесение урона:**
   - Для каждой цели: `tickDamage = baseDamage / 4`
   - `ApplyDamage(target, tickDamage, PHYSICAL)`

4. **Визуальные эффекты:**
   - Создается `VolcanoEffect` на каждой цели
   - Оранжевое кольцо, растущее и затухающее
   - Длительность: 0.25 сек

5. **Трата энергии:**
   - Вычитаем `tickCost` из случайного источника

### TOWER_LIGHTHOUSE (Маяк)

**Тип атаки:** Вращающийся луч

**Параметры:**
- Урон: 35 базовый (1.46 за тик)
- Range: 4 гекса
- Rotation speed: 1.5 радиан/сек
- Arc angle: 90 градусов
- Tick rate: 24 тика в секунду
- Урон увеличен в 4 раза: итоговый урон за сек ≈ 35 * 4 = 140

**Компонент Beacon:**
```
CurrentAngle: текущий угол вращения
RotationSpeed: 1.5 рад/сек
ArcAngle: 90 градусов в радианах
TickTimer: таймер тика
```

**Алгоритм:**

**Каждый кадр:**

1. **Обновление угла:**
   ```
   CurrentAngle += RotationSpeed * deltaTime
   if CurrentAngle > 2π:
     CurrentAngle -= 2π
   ```

2. **Обновление сектора визуализации:**
   ```
   sector.IsVisible = true
   sector.Range = combatRange
   sector.Arc = beacon.ArcAngle
   sector.Angle = beacon.CurrentAngle + π  // коррекция
   ```

**Каждый тик (1/24 сек):**

1. **Проверки:**
   - Башня активна
   - Достаточно энергии

2. **Поиск целей в секторе:**
   - Строим треугольник: `A (башня), B, C (концы дуги)`
   - Для каждого врага проверяем: `isPointInTriangle(enemyPos, A, B, C)`

3. **Нанесение урона:**
   ```
   tickDamage = (baseDamage * 4) / tickRate
   for each target:
     ApplyDamage(target, tickDamage, PURE)
     Create white visual effect
   ```

4. **Трата энергии:**
   - `tickCost = shotCost / tickRate`

**Особенность сектора:**
- Угол коррекции `+ π` компенсирует различие в системах координат рендеринга

### TOWER_JADE (Jade - Стакующийся яд)

**Тип атаки:** Снаряд с особым эффектом

**Параметры:**
- Урон: 5 прямой
- Fire rate: 1.0 атк/сек
- Range: 4 гекса
- Shot cost: 0.12
- Visual: "ELLIPSE" (эллипсоидный снаряд)

**Эффект:**
- Каждое попадание добавляет стак яда
- Стаки живут 5 секунд независимо
- Урон: `(10 * stacks) * (1.1 ^ (stacks-1))`
- Замедление: `5% * stacks`, минимум 10% скорости

**Стратегия:**
- Фокус на одной цели максимизирует урон
- 5 стаков = урон ×1.46
- 10 стаков = урон ×2.36 + 50% замедление

### TOWER_SILVER (Silver - Лазер)

**Тип атаки:** LASER (мгновенный)

**Параметры:**
- Урон: 55
- Fire rate: 1.2 атк/сек
- Range: 4 гекса
- Shot cost: 0.15

**Особенности:**
- Нет времени полета
- Мгновенное попадание
- Визуальный луч 0.15 сек

### TOWER_MALACHITE (Malachite - Сплит + Взрыв)

**Тип атаки:** PROJECTILE с Impact Burst

**Параметры:**
- Урон: 20 прямой
- Split count: 3 снаряда
- Impact burst:
  - Radius: 1.5 гекса
  - Target count: 4
  - Damage factor: 0.4 (8 урона)

**Механика:**
- Стреляет в 3 ближайшие цели
- Каждый снаряд при попадании:
  - Наносит 20 урона первичной цели
  - Создает 4 мини-снаряда по 8 урона
- Итого: до 32 урона на первичную + до 4×8=32 на остальных

---

## 12. СИСТЕМА ОПЫТА И ПРОГРЕССИИ

### Опыт игрока

**Компонент PlayerStateComponent:**
```
Level: текущий уровень (начало: 1)
CurrentXP: текущий опыт
XPToNextLevel: опыт до следующего уровня
Health: здоровье (начало: 100)
```

### Получение опыта

**Источник:** убийство врагов
- За каждого убитого: +10 XP
- Событие: `EnemyKilled`
- Обработчик: `PlayerSystem`

### Повышение уровня

**Формула опыта:**
```
XPForLevel(level) = 100 + (level - 1) * 50
```

Прогрессия:
- Level 1→2: 100 XP
- Level 2→3: 150 XP
- Level 3→4: 200 XP
- ...

**Алгоритм:**
```
CurrentXP += XPPerKill
while CurrentXP >= XPToNextLevel:
  Level++
  CurrentXP -= XPToNextLevel
  XPToNextLevel = CalculateXPForNextLevel(Level)
```

### Влияние уровня

**Loot Tables:**
- Уровень игрока определяет доступные башни
- Можно создавать разные таблицы для разных уровней
- Текущая версия: только Level 1 таблица

**Будущий потенциал:**
- Level 2+: открытие новых башен
- Улучшение весов редких башен

---

## 13. СИСТЕМА ФАЗ ИГРЫ

### Типы фаз

```go
type GamePhase int
const (
  BuildState          // Строительство
  WaveState           // Волна врагов
  TowerSelectionState // Выбор башен для сохранения
)
```

### BuildState (Строительство)

**Возможности:**
- Размещение башен (до 5 башен)
- Удаление башен
- Просмотр рецептов (B)
- Режим перетаскивания линий (U)
- Дебаг-команды (1,2,3,0)

**Ограничения:**
- Нельзя ставить на непроходимые тайлы
- Нельзя блокировать путь Entry→Checkpoints→Exit
- Максимум `MaxTowersInBuildPhase = 5` башен

**Переход в WaveState:**
- Клик по индикатору состояния
- Автоматически при достижении лимита (переход в TowerSelectionState)

### WaveState (Волна)

**Процесс:**
- Враги спавнятся по таймеру
- Башни атакуют
- Враги двигаются
- Враги наносят урон при достижении Exit

**Окончание:**
- `EnemiesToSpawn == 0` И `ActiveEnemies == 0`
- Событие `WaveEnded`
- Автоматический переход в BuildState

**Возможности:**
- Просмотр информации о башнях/врагах
- Просмотр рецептов
- Изменение скорости игры (1x, 2x, 4x)
- Пауза (F9 или кнопка)

### TowerSelectionState (Выбор башен)

**Активация:**
- Когда построено 5 башен в BuildState
- Появляется после 4-й волны (не с самого начала?)

**Механика:**
- Все построенные башни помечены `IsTemporary = true`
- Нужно выбрать `TowersToKeep = 2` башни
- Шахтеры (Miner) выбираются автоматически

**Выбор:**
- Клик по башне переключает `IsSelected`
- Когда выбрано ровно `TowersToKeep` башен:
  - Выбранные: `IsTemporary = false`
  - Не выбранные: превращаются в TOWER_WALL

**Финализация:**
```
FinalizeTowerSelection():
  for each temporary tower:
    if IsSelected:
      IsTemporary = false
    else:
      DeleteTower()
      CreatePermanentWall(hex)
  towersBuilt = 0
  Phase = WaveState
  StartWave()
```

---

## 14. UI И ВИЗУАЛИЗАЦИЯ

### 3D Рендеринг

**Камера:**
- Тип: Perspective / Orthographic (переключение P)
- FOV: 45° (perspective), 160 (orthographic)
- Управление:
  - Q/E: вращение вокруг центра
  - Колесо мыши: изменение FOV (zoom)
  - R/T: zoom in/out
  - Y: сброс zoom

**Позиции камеры:**
```
IsoPos = (144, 200, 144)  // изометрический вид
TopDownPos = (0, 425, 0.1) // вид сверху
Current = Lerp(IsoPos, TopDownPos, cameraAngleT)
```

### Рендеринг башен

**Типы моделей:**
- **Wall**: цилиндр (r=4.59, h=5.7)
- **Miner**: OBJ модель
- **Base attackers**: цилиндр (r=2.45, h=13.87)
- **Crafted towers**: куб 6.1×6.1×6.1

**Высоты:**
```
Wall: radius * 1.5
Miner: radius * 9.0
Crafted: radius * 4.0
Base: radius * 7.0
```

**Цвета:**
- Активная: `TowerDef.Visuals.Color`
- Неактивная: затемненный цвет (0.4 яркости)
- Временная: полупрозрачная
- Выделенная: обводка
- Для крафта: зеленая обводка

**Турели:**
- Модель головы отдельно от базы
- Вращается по CurrentAngle (yaw)
- Наклоняется по CurrentPitch (pitch)
- Применяется матрица поворота

### Рендеринг врагов

**Модели:** сферы

**Размер:**
- Зависит от здоровья:
  ```
  radius = (0.6 + 0.4 * (currentHP / maxHP)) * baseRadius
  ```
- При полном HP: 100% размера
- При 0 HP: 60% размера

**Цвета:** из `EnemyDef.Visuals.Color`

### Рендеринг снарядов

**Batch rendering** для оптимизации

**Типы:**
- Обычный: сфера
- "ELLIPSE": вытянутый эллипсоид

**Высота:**
```
progress = distance_traveled / total_distance
currentHeight = Lerp(spawnHeight, targetHeight, progress)
```

**Анимация появления:**
```
scale = Age / ScaleUpDuration
if scale > 1.0: scale = 1.0
```

### Рендеринг линий энергосети

**Цвет:** золотистый `(255, 195, 0, 150)`

**Высота:** `LineHeight = 5.0`

**Особенности:**
- Соединяют центры гексов башен
- В режиме перетаскивания: одна линия скрыта
- Скрытые линии не рендерятся

### UI Элементы

**StateIndicator (круг справа сверху):**
- BuildState: синий
- WaveState: красный
- TowerSelectionState: желтый
- Клик переключает фазу

**SpeedButton:**
- 3 состояния: 1x, 2x, 4x
- Цвета: синий, красный, желтый
- Клик циклирует скорость

**PauseButton:**
- Играет: синий
- Пауза: красный

**PlayerLevelIndicator:**
- Полоска опыта (зеленая)
- Текст: "Уровень N"
- XP: "XXX / XXX"

**PlayerHealthIndicator:**
- Полоска здоровья
- Цвет зависит от процента:
  - > 50%: синий
  - 25-50%: желтый
  - < 25%: красный

**WaveIndicator:**
- Текст: "Волна N"

**OreSectorIndicator:**
- 3 секции (центр, середина, край)
- Цвета:
  - > 30%: синий
  - 10-30%: желтый
  - 5-10%: красный
  - < 5%: темный
  - 0%: черный

**InfoPanel:**
- Показывается при клике на сущность
- Враг: тип, HP, броня
- Башня: тип, уровень, урон, range, fire rate
- Позиция: справа от курсора

**RecipeBook (B):**
- Список всех рецептов
- Цвет:
  - Серый: недоступен
  - Светлый: доступен
- Кнопка "Combine" при клике на башню
- Кнопка "Select" для выбора в TowerSelectionState

**UIndicator (U):**
- Буква "U" слева от паузы
- Красный: режим перетаскивания активен
- Синий: режим отключен
- Зачеркнут: нельзя использовать (не BuildState)

---

## 15. МЕЛКИЕ МЕХАНИКИ И ТОНКОСТИ

### Режим перетаскивания линий (Line Drag Mode)

**Активация:** U (только в BuildState)

**Цель:** перенаправить линию от башни к другой

**Алгоритм старта:**

1. Клик на башню
2. Определяем направление клика (угол от башни)
3. Находим ближайшую линию в этом направлении (угол < π/3.5)
4. Если найдена линия `Tower1 ↔ Tower2`:
   - `dragSourceTowerID = Tower2` (сосед)
   - `dragOriginalParentID = Tower1` (кликнутая)
   - `hiddenLineID = lineID`
5. Линия скрывается

**Алгоритм финализации:**

1. Клик на новую башню (target)
2. Проверки:
   - Target != Source
   - Target != OriginalParent
   - `isValidConnection(source, target)`
   - Не создает цикл в графе
   - Source остается powered после переподключения
3. Удаляем старую линию
4. Создаем новую: `Source ↔ Target`
5. Очистка осиротевших линий

**Отмена:** ПКМ или U повторно

### Режим Shift+Click (ручной выбор)

**Shift+ЛКМ:**
- Добавляет башню в список `manuallySelectedTowers`
- Если уже выбрана, перемещает в конец
- `Tower.IsManuallySelected = true`

**Shift+ПКМ:**
- Удаляет башню из списка
- `Tower.IsManuallySelected = false`

**Визуализация:**
- Выбранные башни имеют особую обводку

**Крафт:**
- Система крафта ищет комбинации только среди выбранных

### Frustum Culling

**Оптимизация рендеринга:**

```
isSphereOnScreen(center, radius, camera):
  frustum = GetCameraFrustum(camera)
  for each plane in frustum:
    distance = DotProduct(plane.normal, center) + plane.distance
    if distance < -radius:
      return false
  return true
```

Объекты вне фрустума не рендерятся.

### Batch Rendering снарядов

Все снаряды рендерятся за один draw call:
```
rl.Begin(Quads)
for each projectile:
  create billboard quad facing camera
  set texture coords
  draw vertices
rl.End()
```

### Чекпоинты - billboard текстуры

**Римские цифры:** I, II, III, IV, V, VI

**Алгоритм:**
1. Генерируем текстуру из шрифта
2. Создаем quad, всегда смотрящий на камеру
3. Позиция: над гексом на высоте 5.0
4. Размер подстраивается под aspect ratio

**Billboard matrix:**
```
right = (camMatrix.M0, camMatrix.M4, camMatrix.M8)
up = (camMatrix.M1, camMatrix.M5, camMatrix.M9)
v1 = pos + right*(-w/2) + up*(-h/2)
v2 = pos + right*(w/2) + up*(-h/2)
v3 = pos + right*(w/2) + up*(h/2)
v4 = pos + right*(-w/2) + up*(h/2)
```

### Визуальные эффекты

**DamageFlash:**
- Длительность: 0.2 сек
- Цвет: белый
- Эффект: additive blending

**VolcanoEffect:**
- Кольцо, растущее от центра
- MaxRadius определяет размер
- Затухает с Duration

**Laser:**
- Луч от башни к цели
- Учитывает высоты (SpawnHeight и targetHeight)
- Длительность: 0.15 сек

**AoeEffect:**
- Круг на земле
- Растет до MaxRadius
- Затухает

### Pathfinding через чекпоинты

**Проблема:** A* должен пройти через все чекпоинты

**Решение:**
```
fullPath = []
current = Entry
for each checkpoint:
  segment = AStar(current, checkpoint, map)
  fullPath += segment[1:]  // без дублирования
  current = checkpoint
segment = AStar(current, Exit, map)
fullPath += segment[1:]
```

### Валидация размещения башни

**Проверки:**

1. **Фаза:** BuildState
2. **Лимит:** `towersBuilt < MaxTowersInBuildPhase`
3. **Тайл:** существует, проходим, можно ставить башню
4. **Занятость:** нет другой башни
5. **Путь:** не блокирует путь Entry→Checkpoints→Exit

**Проверка блокировки пути:**
```
isPathBlockedBy(hex):
  temporarily set tile.Passable = false
  try AStar from Entry through all Checkpoints to Exit
  restore tile.Passable
  return (path == nil)
```

### PRNG (Pseudo-Random Number Generator)

**Детерминированная генерация:**

```go
type PRNGService struct {
  r *rand.Rand  // с фиксированным seed
}
```

**Использование:**
- Генерация карты
- Порядок чекпоинтов
- Распределение урона врагов
- Выбор башни из loot table

**Преимущества:**
- Воспроизводимость
- Одинаковые результаты при одном seed

### Environmental Damage

**Руда:**
- `OreDamagePerSecond = 5.0`
- `TicksPerSecond = 2.0`
- Враг на руде получает урон (не реализовано в текущей версии?)

**Линии:**
- `LineDamagePerSecond = 10.0`
- `TicksPerSecond = 5.0`
- Враг на линии получает урон (не реализовано в текущей версии?)

### Debug режимы

**Hotkeys:**

- **F3:** Visual Debug Mode
  - Показывает дополнительную информацию
  - Boundingspheres, пути, и т.д.

- **F5:** Reload Models
  - Перезагружает все 3D модели башен
  - Полезно при изменении моделей

- **F9:** Pause

- **F10:** God Mode
  - Враги не наносят урон игроку

**Build Mode hotkeys:**
- **1:** Random Attack tower
- **2:** Miner
- **3:** Wall
- **0:** Lighthouse

### Цветовая схема UI

**Основная палитра:**
- Синий `(44, 85, 119)` - спокойное состояние
- Красный `(169, 68, 66)` - активное состояние
- Желтый `(204, 146, 67)` - предупреждение

**Консистентность:**
- BuildState: синий (спокойно)
- WaveState: красный (опасность)
- SelectionState: желтый (внимание)
- Speed x1: синий
- Speed x2: красный
- Speed x4: желтый

### Оптимизация производительности

**1. Frustum Culling:**
- Проверка видимости перед рендерингом

**2. Batch Rendering:**
- Снаряды рендерятся одним батчем
- Линии рендерятся одним батчем

**3. Инкрементальная энергосеть:**
- При добавлении башни не пересчитывается вся сеть
- Только расширение от новой башни

**4. Delta Time Capping:**
- `MaxDeltaTime = 0.05` (50ms)
- Предотвращает "spiral of death"

**5. Event System:**
- Loose coupling снижает зависимости
- Системы обрабатывают только свои события

---

## ИТОГ

Игра имеет **чрезвычайно глубокую и продуманную систему механик**:

1. **Энергосеть** - уникальная механика с MST, деградацией и перетаскиванием
2. **Руда** - процедурная генерация с балансом и бонусами
3. **Крафт** - комбинаторная система с автопоиском
4. **Башни** - разнообразные типы атак и эффектов
5. **Враги** - броня, эффекты, динамические пути
6. **Фазы** - чередование строительства и защиты
7. **Прогрессия** - опыт, уровни, loot tables

Каждая система продумана до мелочей и взаимодействует с другими через события и интерфейсы.
