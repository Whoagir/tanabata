# Риски при расширении игры

Где код может «споткнуться» при добавлении новых пушек, локаций, систем прокачки, статистики и т.п. Что вынести и какие идеи применить глобально.

---

## 1. Новые типы башен (пушки)

### Где завязано на тип (MINER / ATTACK / WALL)

- **input_system.gd**
  - `_create_tower_entity`: ветки только для `type == "MINER"` (auto-select), `type == "ATTACK"` + combat (добавление combat/aura). Новый тип (например BEACON, AOE) потребует новых `if` и дублирования логики компонентов.
  - `_determine_tower_id`: RANDOM_ATTACK захардкожен как `["TA", "TE", "TO", "PA", "PE", "TOWER_SILVER"]` — новые башни из JSON в этот список не попадут.
- **entity_renderer.gd**
  - `_create_tower_visual`, `_update_tower_color`, `_update_tower_highlight`: `match tower_type` только MINER / WALL / иначе (ATTACK). Четвёртый тип — снова ветка и форма/цвет.
- **tower_preview.gd**
  - `_create_preview`: match по MINER / ATTACK / WALL; по умолчанию круг.
- **wall_renderer.gd**, **energy_network_system.gd**
  - Проверки `type == "WALL"`, `type == "MINER"` и т.д. по строке. Новый тип — везде добавить условие.
- **combat_system.gd**
  - Тип атаки: только `attack_method == "LASER"` и иначе PROJECTILE. AOE/BEACON из GameTypes не обрабатываются — добавление = новый ветки в update и новые функции создания атак.

### Что сделать глобально

- **Единая фабрика башен по def_id:** один модуль (например `TowerFactory` или расширение GameManager), который по `tower_def` из JSON создаёт сущность и вешает нужные компоненты (tower, combat, aura, renderable и т.д.) по полям def, без перечисления типов в коде. Тип башни — данные (например `def["type"]`), а не список `if type == "MINER"` по всему проекту.
- **Рендер по конфигу:** форма/цвет башни из `tower_def.visuals` (форма: circle/hex/triangle, превью-форма и т.д.), а не жёсткий match по трём типам. Новый тип = новая запись в JSON и при необходимости новое значение в enum/строке.
- **Список «атакующих» для RANDOM_ATTACK:** формировать по данным (все def с `type == "ATTACK"` или отдельный тег в JSON), а не хардкод массива id.

---

## 2. Лимиты и константы (5 башен, 2 сохранить)

### Где зашито число «2»

- **config.gd:** `TOWERS_TO_KEEP = 2`, `MAX_TOWERS_IN_BUILD_PHASE = 5` — единственная нормальная точка правды.
- **info_panel.gd:** проверки `saved_count >= 2` и `final_saved_count >= 2` — **литерал 2**, не `Config.TOWERS_TO_KEEP`. При смене лимита (например 3 башни сохранять) здесь останется 2 и логика сломается.
- **input_system.gd:** пишет `ecs.game_state["towers_to_keep"] = Config.TOWERS_TO_KEEP`, в print использует `ecs.game_state.get("towers_to_keep", 2)` — дефолт 2 дублирует константу.

### Что сделать

- Везде использовать **только** `Config.TOWERS_TO_KEEP` (или `ecs.game_state.get("towers_to_keep", Config.TOWERS_TO_KEEP)`). В info_panel заменить оба `2` на константу из Config.
- Если лимиты будут зависеть от уровня/локации/сложности — вынести в «правила фазы» (например структура/ресурс PhaseRules с max_towers, towers_to_keep), а не размазывать магические числа по UI и системам.

---

## 3. Волны и контент волн

### Где можно сломаться

- **game_manager.gd, get_wave_def:** после волны 10 цикл жёстко задан: `actual_wave = 6 + ((wave_number - 11) % 5)` (волны 6–10 по кругу). Смена схемы (другая линейка, «бесконечные» волны, ветки по уровню) потребует менять эту формулу и, возможно, контракт волн (не только номер).
- **wave_system.gd:** ожидает в def поля `count`, `enemy_id`, `spawn_interval`. Новые механики (несколько типов врагов в одной волне, босс, тайминги по фазам) — расширение структуры и правки в одном месте, но без единого «формата волны» легко получить рассинхрон с JSON и другими системами.

### Что сделать

- **Схема волн в одном месте:** описать формат волны (и опционально «режим»: linear / repeat_6_10 / endless / campaign) в конфиге или в коде один раз (например WaveScheme), а get_wave_def только применяет схему. Новые локации/режимы = новые схемы, без правок формул в GameManager.
- По возможности держать расширения волны (несколько enemy_id, босс-флаг) в данных (JSON), а код — обобщённым циклом по полям.

---

## 4. Локации / несколько карт

### Текущее состояние

- **Один экземпляр карты:** `GameManager.hex_map` и `GameManager.map_seed` глобальные. Нет понятия «уровень», «локация», «выбор карты».
- **game_manager.gd:** в _ready создаётся одна HexMap с Config.MAP_RADIUS и randi() seed. Генерация руды и начальных стен привязаны к этой карте.
- **wave_system, pathfinding, input_system, ore_generation_system, aura_system:** везде используется один и тот же hex_map (напрямую или через GameManager).

### Где будет больно

- Смена карты между играми или «выбор уровня» потребует: пересоздавать/подменять hex_map, перегенерировать руду, пересоздать стены, сбросить ECS-сущности, привязанные к гексам/карте. Сейчас всё завязано на один глобальный hex_map.
- Разные размеры/правила карты (другой радиус, другое число чекпоинтов) — константы размазаны (MAP_RADIUS, 6 чекпоинтов в hex_map и т.д.).

### Что сделать глобально

- **Понятие «текущая локация/уровень»:** либо сцена/контекст с своей картой и правилами (HexMap + LevelConfig), либо явный объект CurrentLevel с hex_map, wave_defs для уровня, лимитами. GameManager тогда хранит «текущий уровень» и отдаёт его системам, а не один hex_map на всё.
- **Генерация карты/руды/стартовых стен** вызывать из одного места при старте уровня (init_level / load_location), а не только из _ready GameManager. Тогда смена локации = вызов того же потока с другими параметрами/ресурсами.

---

## 5. Статистика

### Где хранится и как используется

- **game_state (ecs_world):** только `total_enemies_killed`, `towers_built_this_phase`, `current_wave`. Инициализация в `init_game_state()` в ecs_world.gd — фиксированный набор ключей.
- **player_states:** у игрока есть `level`, `current_xp`, `xp_to_next_level`, `health`. XP нигде не начисляется (нет вызова при убийстве врага) — прокачка «заглушена».
- Убийство врага: в projectile_system и combat_system только инкремент `total_enemies_killed`. Никакой передачи в «статистику» или «прогресс».

### Где будет проблема

- Добавление любой новой статистики (убийств по типам, урона, башен поставлено за сессию, рекорды волн и т.д.):
  - нужно не забыть инициализировать в init_game_state;
  - обновлять в разных местах (комбат, волны, инпут);
  - UI и сохранения будут искать эти поля вручную.
- Разбросанные `game_state["key"]` и `game_state.get("key", default)` — при добавлении ключа легко пропустить инициализацию или чтение.

### Что сделать глобально

- **Единый слой статистики/прогресса:** один модуль (например GameStats или расширение GameManager), который:
  - объявляет все ключи (и при необходимости типы/дефолты);
  - предоставляет API: increment_kill, add_xp, set_phase_counter и т.д.;
  - при старте игры/уровня инициализирует все поля.
- **Начисление XP:** в одном месте «враг убит» (например событие или вызов из projectile_system/combat_system) вызывать что-то вроде `GameStats.grant_xp(amount)` или `Progression.on_enemy_killed(enemy_def_id)`, а формула «сколько XP за какого врага» — в конфиге или данных.
- Не хранить десятки разнородных счётчиков прямо в game_state без списка: либо подструктуры (stats.kills, stats.towers_placed), либо явный реестр в одном файле.

---

## 6. Прокачка (уровень, XP)

### Текущее состояние

- Игрок создаётся с level=1, current_xp=0, xp_to_next_level=Config.calculate_xp_for_level(1). Никакой код не меняет current_xp и не повышает level.
- get_loot_table_for_level и _pick_from_loot_table используют player_level для выбора башни при размещении. Уровень не растёт — лут-таблица по сути не прогрессирует.

### Где споткнёмся

- Добавление «XP за убийство»: нужно вызывать начисление в projectile_system и combat_system (и не забыть при других причинах смерти). Без единой точки (например OnEnemyKilled) легко дублировать или пропустить.
- Повышение уровня (current_xp >= xp_to_next_level): сброс current_xp, пересчёт xp_to_next_level, возможно разблокировка контента. Сейчас такой логики нет — при её добавлении лучше держать в одном сервисе прокачки.

### Что сделать

- **Сервис прокачки (одно место):** например `Progression` или функции в GameManager: `grant_xp(amount)`, внутри — прирост current_xp, проверка на уровень, обновление xp_to_next_level. Вызов только из «событие: враг убит» (и при желании из квестов/бонусов).
- **Связь «враг убит» → XP:** либо dispatch_event(ENEMY_KILLED, {enemy_id, def_id}) и подписчик начисляет XP по def, либо одна функция типа GameManager.on_enemy_killed(enemy_id), которую вызывают и projectile_system, и combat_system. Так не будет дублирования и забытых мест.

---

## 7. Фазы игры и переходы

### Где дублируется логика

- **Переход BUILD → SELECTION:** game_root (_cycle_phase по Space), game_hud (клик по индикатору). Логика «сменить phase» повторена.
- **Переход SELECTION → WAVE:** game_hud (клик по индикатору: _remove_unselected_towers, сброс выделения, закрытие InfoPanel, phase = WAVE) и info_panel (при сохранении второй башни: _finalize_tower_selection, phase = WAVE, hide_panel). Финализация выбора башен и смена фазы продублированы.
- **Переход WAVE → BUILD:** game_root (_cycle_phase: _clear_entities, phase = BUILD) и game_hud (клик: _clear_enemies, _clear_projectiles, сброс towers_built_this_phase, снятие temporary с башен, phase = BUILD). Очистка сущностей и сброс состояния дублируются.

### Риск при расширении

- Новые фазы (например MENU, SHOP, между волнами) или условия перехода (таймер, кнопка «Готово») потребуют править несколько файлов и легко получить рассинхрон (в одном месте переход делается, в другом — нет).

### Что сделать глобально

- **Один оркестратор фаз:** один модуль (например PhaseController или методы в GameManager): `request_phase(new_phase)` или `transition_to(next_phase)`. Внутри — все действия при переходе: очистка сущностей, финализация выбора, сброс счётчиков, смена game_state["phase"], закрытие панелей. UI и хоткеи только вызывают request_phase(...).
- **Описание переходов в одном месте:** какие переходы разрешены (BUILD→SELECTION→WAVE→BUILD), какие действия при каждом — код/таблица в одном файле. Тогда новые фазы и новые действия при переходе добавляются там, а не в game_root + game_hud + info_panel.

---

## 8. Создание стены (перманентной)

### Где дублируется

- **game_manager.gd** (_place_initial_walls): создание сущности стены, tower + renderable, set_tile, place_tower.
- **game_hud.gd** (_create_permanent_wall): то же самое, с тем же набором полей tower.
- **info_panel.gd** (_create_permanent_wall): то же.

Любое изменение (новое поле в tower, другой визуал, другой def_id для «варианта стены») нужно вносить в три места — легко забыть одно и получить баг.

### Что сделать

- **Одна функция создания стены:** например `GameManager.create_wall_at(hex)` или общая `TowerFactory.create_wall(hex)` (если фабрика башен будет). Внутри — создание entity, компоненты, привязка к карте. Вызов только из game_manager (начальные стены), game_hud и info_panel (конвертация невыбранных башен).

---

## 9. UI и макеты

### Где зашиты размеры/зоны

- **game_root.gd, _is_ui_area:** координаты 270, 100, 60, 160, 70 захардкожены. Смена размера окна, добавление панелей, сдвиг кнопок — нужно править код и подбирать числа заново.
- **game_hud.gd:** позиции кнопок (Config.SCREEN_WIDTH - 60, Config.SCREEN_HEIGHT - 60 и т.д.), размеры панелей. Новые элементы — снова магические числа.

### Что сделать

- Вынести зоны кликов и размеры в Config или в один UI-конфиг (например rect панели, отступы). _is_ui_area использовать константы/ресурс, а не голые числа.
- По возможности строить UI из сцен/нод с привязкой к краям (anchors), чтобы при смене разрешения не ломать логику.

---

## 10. Типы урона и атак

### Где зашито

- **projectile_system.gd, combat_system.gd:** match по attack_type.to_upper() (PHYSICAL, MAGICAL, PURE, SLOW, POISON). Цвет снаряда/лазера — ещё один match. Новый тип урона = правки в двух системах и в Config (цвет).
- **combat_system:** создание атаки только PROJECTILE и LASER. AOE, BEACON из GameTypes не обрабатываются — отдельные ветки и логика.

### Что сделать

- **Таблица типов урона:** в Config или в данных (JSON) — тип → цвет, флаги (игнорирует броню и т.д.). Код один раз получает запись по типу и применяет; новый тип = новая строка в данных.
- **Регистрация обработчиков атак:** вместо одного большого match по типу атаки — словарь «тип атаки → функция создания» (или классы атак). Добавление AOE/BEACON = новая функция и регистрация, без правок основной ветки комбата.

---

## 11. Инициализация состояния игры

### Где риск

- **ecs_world.gd, init_game_state:** фиксированный набор ключей. Любая новая глобальная переменная (например best_wave, total_damage_dealt) должна быть добавлена сюда и во все места чтения. Забыли в init — получим неинициализированное значение при .get().

### Что сделать

- Либо **единый реестр ключей game_state** (массив/словарь «ключ → default»), по которому init заполняет game_state, а код везде читает через обёртку типа GameState.get(key). Либо явный модуль GameStats (см. выше), который владеет всеми счётчиками и сам инициализирует их при старте.

---

## 12. Краткая сводка: что вынести

| Что | Куда / как |
|-----|------------|
| Создание башни по def_id | Одна фабрика (TowerFactory / GameManager): компоненты из JSON, без перечисления типов в if/match |
| Создание стены | Одна функция create_wall_at(hex), вызов из всех трёх мест |
| Лимит «сколько сохранить» | Везде Config.TOWERS_TO_KEEP, убрать литерал 2 из info_panel |
| Переходы фаз | Один PhaseController: request_phase() и все действия при смене фазы |
| Статистика и прогресс | Один слой (GameStats / Progression): ключи, инициализация, grant_xp, increment_kill и т.д. |
| «Враг убит» | Одна точка (событие или on_enemy_killed), оттуда — счётчик убийств и начисление XP |
| Схема волн (цикл 6–10) | Вынести в «схему»/конфиг волн, get_wave_def только применяет схему |
| Карта/уровень | Понятие «текущий уровень» (hex_map + правила), смена локации = подмена уровня |
| Зоны UI | Константы/конфиг для _is_ui_area и позиций кнопок |
| Типы урона/атак | Данные (тип → цвет, флаги); обработчики атак — регистрация по типу, а не один большой match |

---

## 13. Файлы, которые править в первую очередь при расширении

- **Новый тип башни:** input_system (_create_tower_entity, _determine_tower_id), entity_renderer (_create_tower_visual, _update_tower_*, tower_type), tower_preview, energy_network_system (type checks), wall_renderer (type WALL).
- **Новый тип атаки (AOE/BEACON):** combat_system (update, создание атак).
- **Новая фаза или правило перехода:** game_root (_cycle_phase), game_hud (_on_state_indicator_clicked), info_panel (переход при 2 сохранённых).
- **Новая статистика / прокачка:** ecs_world (init_game_state), projectile_system / combat_system (где считаются убийства), места отображения в HUD.
- **Несколько карт/локаций:** game_manager (_ready, создание hex_map и руды), все системы, берущие hex_map у GameManager.

Имеет смысл перед крупным расширением ввести перечисленные «единые точки» (фабрика башен, фаза, статистика, уровень), а уже поверх них добавлять новый контент и режимы.
