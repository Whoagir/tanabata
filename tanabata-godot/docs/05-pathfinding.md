# Поиск пути (Pathfinding)

## Алгоритм A*

Поиск кратчайшего пути между двумя гексами. Учитывает только проходимые тайлы (passable). Стоимость перехода между соседними гексами — 1.

**Оптимизации:**

- **Min-heap** — frontier хранится как min-heap по f = cost + heuristic. Вставка и извлечение — O(log n).
- **Int-ключи** — внутренние Dictionary (came_from, cost_so_far, closed) используют `Hex.int_key_from_qr()` — арифметический int вместо String formatting. ~3x быстрее lookup.
- **Инлайн-соседи** — итерация по `_DIR_Q[d]`/`_DIR_R[d]` вместо `get_neighbors()`. 0 аллокаций Hex и Array в основном цикле.
- **`is_passable_qr(q, r)`** — проверка тайла без создания Hex объекта.
- **Heap хранит [f, q, r]** вместо [f, Hex] — Hex создаются только при реконструкции пути.
- **Инлайн-эвристика** — `_hex_dist(q1, r1, q2, r2)` вместо вызова метода на Hex объекте.

## Путь через чекпоинты

Враги идут не напрямую, а через цепочку чекпоинтов:

Entry → Checkpoint 1 → Checkpoint 2 → ... → Exit

Путь собирается из отрезков: A* от точки до точки. Башни считаются непроходимыми, поэтому путь огибает их.

**Летающие враги:** для них путь строится с условной вставкой **центра карты** (Hex.ZERO):
- Вход: если чекпоинт 1 входит в два самых дальних от входа — маршрут Entry → центр → CP1; иначе Entry → CP1.
- Между CP i и CP i+1: центр вставляется только если расстояние (CP i → CP i+1) больше, чем (CP i+1 → CP i+2).
- Выход: если чекпоинт 6 входит в два самых дальних от выхода — маршрут CP6 → центр → Exit; иначе CP6 → Exit.

Так выравнивается баланс карт для летающих.

## Когда пересчитывается путь

- При старте игры (GameRoot) вызывается `update_future_path()` сразу.
- При постановке/снятии башни и при смене фазы (BUILD↔SELECTION↔WAVE) вызывается **`_request_future_path_update()`** с **дебаунсом 0.08 с**: таймер сбрасывается при каждом новом запросе, поэтому несколько быстрых действий дают один пересчёт пути через 0.08 с. Это снижает нагрузку при частом размещении башен.

Путь используется для предпросмотра трассы врагов (отрисовка на карте) и не пересчитывается во время волны для уже идущих врагов.

## Блокировка пути

При постановке башни тайл становится непроходимым. Проверка блокировки использует `path_exists_through_checkpoints()` — A* без реконструкции пути (без came_from, возвращает bool). Это ~3-5x быстрее полного `find_path()`.

## path_exists()

`path_exists(start, goal, hex_map)` — облегчённый A*, возвращающий true/false без построения массива пути. Не хранит `came_from`, не вызывает `_reconstruct_path`. Используется в `_would_block_path()` для проверки блокировки при постановке башни.

`path_exists_through_checkpoints()` — проверка через все чекпоинты с early-exit (если первый сегмент заблокирован, остальные не проверяются).

## Кэш путей (WaveSystem)

Ground и flying пути считаются один раз при `start_wave()` и кэшируются в `_cached_ground_path` / `_cached_flying_path`. При спавне враги берут путь из кэша. Карта не меняется во время волны, поэтому пересчёт не нужен.
