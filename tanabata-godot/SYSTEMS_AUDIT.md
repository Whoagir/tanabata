# Аудит систем проекта

Оценка по шкале 0–100: насколько система используется, насколько качественно, в полную ли мощность. Отдельно выделены исключения (что намеренно вне ECS или не по архитектуре).

---

## 1. ECS (ecs_world.gd)

**Оценка: 72/100**

**Используется хорошо:**  
Сущности создаются/уничтожаются через `create_entity` / `destroy_entity`. Основные данные живут в ECS: башни, враги, снаряды, руда, волны, игрок, позиции, здоровье, рендерабл, пути, статус-эффекты, ауры, линии энергосети, вспышки урона, лазеры. Системы читают/пишут компоненты, рендеры опираются на ECS. `has_component` / `add_component` используются по коду последовательно.

**Не в полную мощность:**  
Ряд компонентов объявлены и очищаются в `destroy_entity`, но нигде не заполняются и не читаются: `turrets`, `beacons`, `beacon_sectors`, `volcano_auras`, `volcano_effects`, `combinables`, `texts`, `aoe_effects`, `manual_selection_markers`. Это задел под маяки/вулканы/крафт — сейчас мёртвый код. `velocities` пишется при спавне врага (ZERO), но ни одна система его не читает (движение по path, не по velocity). В `add_component` дублируются ветки для `"energy_line"` и `"ore"`.

**Исключения / вне ECS:**  
`game_state` хранится в ECS как один общий словарь (фаза, пауза, скорость времени, волна, счётчики). По смыслу это глобальное состояние игры, а не сущность — логически это синглтон вне сущностной модели, просто положен в ECS для единой точки доступа.

---

## 2. Игровой цикл и GameManager

**Оценка: 48/100**

**Как задумано:**  
GameManager — автолоад, создаёт ECS и hex_map, загружает данные, в `_process` ограничивает delta, учитывает паузу и скорость времени, накапливает fixed timestep и вызывает `update_simulation(Config.FIXED_DELTA)`. В `update_simulation` цикл по массиву `systems` с вызовом `system.update(delta)`.

**Проблема:**  
Массив `systems` нигде не заполняется. В GameRoot системы создаются и вызываются вручную в `_process`: `input_system.update(delta)`, `wave_system.update(scaled_delta)` и т.д. То есть фиксированный шаг в GameManager по сути не используется для геймплея — симуляция идёт с переменным delta из GameRoot. Получается два параллельных контура: «официальный» (пустой) в GameManager и реальный в GameRoot. Либо нужно регистрировать системы в `GameManager.systems` и гонять их из `update_simulation`, либо убрать fixed timestep/`systems` и признать единственным местом вызова систем GameRoot.

**Используется нормально:**  
GameManager создаёт и хранит ECS, hex_map, energy_network, загружает tower_defs, enemy_defs, wave_defs, loot_table_defs, даёт API (get_tower_def, get_wave_def, pause, phase и т.д.). Всё это востребовано.

---

## 3. Игровые системы (Input, Wave, Movement, Combat, Projectile, StatusEffect, Aura)

**Оценка в среднем: 78/100**

- **InputSystem (82):** Очередь команд, фазы, размещение/снятие башни, выбор, проверка пути при постановке. Используется плотно. Минус: дублирование логики «какой тип башни ставим» с wall_renderer и tower_preview; двойной вызов rebuild_energy_network в remove_tower.
- **WaveSystem (85):** Старт волны, путь через чекпоинты, спавн врагов по таймеру, завершение волны, переход фазы. Хорошо опирается на ECS и hex_map. Pathfinding вызывается один раз при старте волны.
- **MovementSystem (80):** Движение по path, учёт slow, чекпоинты, урон игроку при достижении выхода. Логика ясная. Минус: ветка `jade_poison` не используется (словарь пустой).
- **CombatSystem (75):** Поиск целей, снаряды/лазеры, расход энергии, кэш источников питания. Работает. Минусы: `hex_map` в _init не используется; своя формула бонуса руды вместо Config; дублирование логики урона с projectile_system.
- **ProjectileSystem (78):** Движение снарядов, попадание, урон, броня, статус-эффекты, вспышки, лазеры. Завязан на ECS. Дублирование расчёта урона с combat_system.
- **StatusEffectSystem (82):** Таймеры slow/poison, снятие по истечении, урон от яда. Простая и используемая по назначению.
- **AuraSystem (85):** Пересчёт aura_effects по активным башням с аурой, радиус, буст скорострельности. Чисто на ECS и hex_map, без лишнего.

**Исключение:**  
Системы вызываются только из GameRoot._process (при непаузе), не из GameManager.update_simulation. Порядок вызова (input → wave → movement → status_effect → aura → combat → projectile) зашит в GameRoot, а не в общем реестре систем.

---

## 4. EnergyNetworkSystem

**Оценка: 80/100**

Живёт в GameManager, не в GameRoot. Используется при постановке башни (add_tower_to_network), при сносе (rebuild_energy_network), при финализации выбора башен (HUD, InfoPanel), при истощении руды в combat. Поиск источников питания для атакующих башен — через `_find_power_sources` (вызывается из CombatSystem). Логика MST, UnionFind, перехват майнер-майнер линий, активация/деактивация башен по подключению к руде — реализована и задействована.

**Не в полную мощность:**  
Много отладочных print в `_is_on_ore` при каждой проверке гекса — в релизе лучше отключать или вести под флагом. Публичный API по сути два: add_tower_to_network и rebuild_energy_network; внутренний _find_power_sources вызывается из combat_system — связность высокая, но зависимость combat → energy_network жёсткая.

**Исключение:**  
Энергосеть — отдельная система вне списка «игровых систем» в GameRoot; обновляется по событиям (поставили/сняли башню, сменили фазу), а не в каждом кадре. Это осознанное решение и уместно.

---

## 5. OreGenerationSystem

**Оценка: 70/100**

Вызывается один раз из GameManager._ready в `_generate_ore()`. Генерация жил, центры, распределение мощности, создание сущностей руды в ECS — всё на ECS и hex_map. Руда потом используется энергосетью, комбатом и рендером.

**Минусы:**  
Константы 240–270 захардкожены вместо Config.TOTAL_MAP_POWER_MIN/MAX. Переменная `ore_vein_hexes` не используется. Система не «система в цикле», а одноразовый генератор — название может вводить в заблуждение (ожидание update каждый кадр).

---

## 6. HexMap

**Оценка: 88/100**

Используется последовательно: генерация карты, тайлы, проходимость, размещение/снятие башен, entry/exit/checkpoints, начальные стены, зоны исключения. Pathfinding и волны опираются на hex_map. Двойная запись «башня на гексе»: tower_id в tile и позиция/hex в ECS — нормально для связки карта ↔ сущности.

**Мелкие моменты:**  
_get_exclusion_zones учитывает только entry/exit, а is_in_exclusion_zone ещё и checkpoints — стоит согласовать с дизайном. В целом система загружена хорошо и по назначению.

---

## 7. Pathfinding

**Оценка: 82/100**

Статический класс, A* по гексам. Вызывается из: wave_system (путь через чекпоинты при старте волны), input_system (_would_block_path при проверке установки башни), hex_map (генерация — проверка пути при удалении секций/углов). Один контракт: find_path(start, goal, hex_map), find_path_through_checkpoints — используется по делу.

**Не в полную мощность:**  
Фронт хранится как массив, выбор минимальной стоимости — линейный обход. На больших картах имеет смысл заменить на приоритетную очередь (heap) для настоящего A*.

---

## 8. UnionFind

**Оценка: 90/100**

Используется только в EnergyNetworkSystem: построение MST при пересборке сети и проверка циклов при добавлении соединений. API минимальный (find, union, при необходимости connected/clear), без лишних зависимостей. В полную силу под задачу.

---

## 9. Config (autoload)

**Оценка: 85/100**

Константы экрана, гекса, карты, баланса, цветов, путей к JSON — используются по всему проекту. Функции load_json, calculate_xp_for_level, calculate_ore_boost_multiplier востребованы. Одна формула бонуса руды в Config не совпадает с той, что в combat_system — две разные «истины». LINE_HEIGHT объявлена, но нигде не используется. В целом конфиг загружен сильно и централизованно.

---

## 10. GameTypes

**Оценка: 75/100**

Энумы и константы (GamePhase, TowerType, AttackType, DamageType, INVALID_ENTITY_ID) используются в коде. game_phase_to_string, tower_type_to_string и т.п. — для логов и отладки. EventType объявлен, но dispatch_event нигде не вызывается — событийная модель не задействована. get_damage_type_color в GameTypes не вызывается (цвета снарядов берутся из Config в combat_system). Часть типов/утилит в полную силу, часть — задел или мёртвый код.

---

## 11. Рендеринг (Entity, Wall, Ore, EnergyLine, Aura, TowerPreview)

**Оценка в среднем: 80/100**

- **EntityRenderer (82):** Башни, враги, снаряды, лазеры, подсветка гексов, соединения майнеров. Пулы для врагов и снарядов (NodePool). Жёстко опирается на ECS и слои из GameRoot. Есть неиспользуемые функции (треугольники, hexagram, _create_entity_visual).
- **WallRenderer (85):** Стены по ECS (tower type WALL), связи между соседями, обводки, превью линий при постановке. Вызывается из GameRoot и при force_immediate_update из input_system. Используется по полной.
- **OreRenderer (80):** Рендер руды из ECS, пульсация, лейблы. Инициализация с ecs в конструкторе, обновление в _process. Нормально.
- **EnergyLineRenderer (82):** Линии по ecs.energy_lines, создание/обновление Line2D. Простой и по назначению.
- **AuraRenderer (78):** Круги аур для активных башен с aura. Удаление при неактивной башне. Работает; охват только визуал аур.
- **TowerPreview (75):** Превью башни под курсором в фазе BUILD. Дублирует логику «какой тип башни» с input_system и wall_renderer; возвращает тип (MINER/ATTACK/WALL), а не def_id.

**Исключение:**  
MetaballWallRenderer есть в проекте (скрипт + шейдер), но нигде не создаётся и не добавляется в сцену. В игре используется только обычный WallRenderer. Metaball — альтернативная/экспериментальная реализация, фактически не используется.

---

## 12. NodePool

**Оценка: 88/100**

Используется в EntityRenderer для врагов и снарядов: предсоздание узлов, acquire/release, reset при возврате. Уменьшает аллокации при частом спавне/удалении. В полную силу под задачу, без избыточности.

---

## 13. UI (GameHUD, InfoPanel)

**Оценка: 72/100**

**GameHUD:** Отображает здоровье, волну, число башен, убийства, индикатор фазы, кнопки скорости и паузы, оверлей паузы. Переход фаз (BUILD → SELECTION → WAVE → BUILD) и связанная логика (очистка врагов/снарядов, финализация выбора башен, создание стен на месте невыбранных) реализованы в HUD. Дублирование: _create_permanent_wall и логика финализации выбора повторяются в InfoPanel.

**InfoPanel:** Показ информации о башне/враге, кнопка «Сохранить»/«Отменить» в фазе выбора, финализация при сохранении двух башен. Та же логика создания стены и пересборки энергосети, что и в HUD — два места поддержки одного поведения.

**Исключение:** Часть игровой логики (смена фаз, очистка сущностей, превращение башен в стены) живёт в UI, а не в отдельной игровой системе или GameManager. Это усложняет единую точку истины и тестирование.

---

## 14. Profiler (autoload)

**Оценка: 55/100**

Включение/вывод в GameRoot (Shift+PageUp, отрисовка при visual_debug_mode). Замеры есть в entity_renderer (render_towers, render_enemies, render_projectiles), wave_system, movement_system. Нет замеров в combat_system, projectile_system, status_effect_system, aura_system, input_system — покрытие неравномерное. Используется как вспомогательный инструмент, но не систематически по всем тяжёлым путям.

---

## 15. Событийная система (GameManager.dispatch_event / event_dispatched)

**Оценка: 0/100**

Сигнал event_dispatched и функция dispatch_event объявлены, типы событий заданы в GameTypes.EventType. Ни один скрипт не вызывает dispatch_event и не подписывается на event_dispatched. Событийная модель не используется — задел на будущее или мёртвый код.

---

## 16. Данные (tower_defs, enemy_defs, wave_defs, loot_table_defs, recipe_defs)

**Оценка: 78/100**

tower_defs, enemy_defs, wave_defs, loot_table_defs активно используются через get_tower_def, get_enemy_def, get_wave_def, get_loot_table_for_level в системах, рендере и UI. recipe_defs загружаются из JSON и кладутся в GameManager, но ни один код не читает recipe_defs (нет get_recipe, крафта и т.п.) — рецепты не задействованы. Остальные данные — в полную силу.

---

## Сводная таблица оценок

| Система / подсистема           | Оценка | В полную ли мощность | Примечание |
|-------------------------------|--------|------------------------|------------|
| ECS                           | 72     | Нет                    | Много пустых компонентов, velocity не читается |
| Игровой цикл / GameManager    | 48     | Нет                    | systems пустой, fixed timestep не управляет симуляцией |
| InputSystem                   | 82     | Почти                  | Дубли логики типа башни, двойной rebuild |
| WaveSystem                   | 85     | Да                     | — |
| MovementSystem                | 80     | Почти                  | jade_poison не используется |
| CombatSystem                  | 75     | Почти                  | Свой бонус руды, дубль урона с projectile |
| ProjectileSystem              | 78     | Почти                  | Дубль урона с combat |
| StatusEffectSystem            | 82     | Да                     | — |
| AuraSystem                    | 85     | Да                     | — |
| EnergyNetworkSystem           | 80     | Да                     | Много print в _is_on_ore |
| OreGenerationSystem           | 70     | Частично               | Одноразовый генератор, хардкод констант |
| HexMap                        | 88     | Да                     | Несогласованность exclusion zones |
| Pathfinding                   | 82     | Почти                  | Нет heap в A* |
| UnionFind                     | 90     | Да                     | — |
| Config                        | 85     | Почти                  | LINE_HEIGHT не используется, две формулы руды |
| GameTypes                     | 75     | Частично               | EventType и get_damage_type_color не используются |
| EntityRenderer                | 82     | Почти                  | Мёртвый код (треугольники и т.д.) |
| WallRenderer                  | 85     | Да                     | — |
| OreRenderer                   | 80     | Да                     | — |
| EnergyLineRenderer            | 82     | Да                     | — |
| AuraRenderer                  | 78     | Да                     | — |
| TowerPreview                  | 75     | Почти                  | Дубли логики типа башни |
| NodePool                      | 88     | Да                     | — |
| GameHUD / InfoPanel           | 72     | Частично               | Дубли логики, часть геймплея в UI |
| Profiler                      | 55     | Нет                    | Неравномерное покрытие систем |
| События (dispatch_event)       | 0      | Нет                    | Не используется |
| Данные (defs)                 | 78     | Почти                  | recipe_defs не читаются |
| MetaballWallRenderer          | —      | Не используется         | Не подключён к сцене |

---

## Что намеренно или фактически вне ECS

- **HexMap:** карта и тайлы — отдельно от ECS; в ECS хранятся позиции сущностей и hex у башен/врагов/руды. Дублирование «кто на гексе» между tile.tower_id и ECS — осознанное (карта для навигации и размещения, ECS для компонентов).
- **game_state:** глобальное состояние (фаза, пауза, скорость, волна, счётчики) лежит в ECS как один словарь, но по смыслу это не сущность, а синглтон-состояние.
- **Камера, слои, курсор:** полностью вне ECS, что корректно.
- **Логика фаз и «кто что может ставить»:** частично в InputSystem, частично в UI (HUD, InfoPanel) и в tower_preview / wall_renderer — единой «системы правил фазы» нет.
- **EnergyNetworkSystem:** не в списке систем GameRoot, обновляется по событиям (постановка/снятие башни, смена фазы) — архитектурно выделена отдельно от пошаговой симуляции.

Файл можно использовать как чеклист для приведения архитектуры к единому стилю и доведения недогруженных систем до полной мощности.
