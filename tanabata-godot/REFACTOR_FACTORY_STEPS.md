# Рефакторинг фабрики сущностей — пошаговый план

Цель: сделать добавление новых башен (кварц, минус-армор, второй уровень крафта) без размазанных `if type == "MINER"` по коду и без всплеска багов.

**Принцип:** каждый шаг — один маленький объём изменений, после каждого шага можно запустить игру и проверить, что всё работает как раньше. Не переписываем всё разом.

---

## Фаза 0: Подготовка (без изменения поведения)

### Шаг 0.1 — Вынести «рецепт» компонентов в подфункцию

**Где:** `core/ecs/entity_factory.gd`

**Что сделать:** Внутри `create_tower` сейчас: создание entity, позиция, tower-компонент, renderable, для ATTACK — combat и опционально aura, затем `hex_map.place_tower`. Вынести всё, что идёт **после** `create_entity()` и **до** `hex_map.place_tower()`, в отдельную статическую функцию, например:

- `_apply_tower_components(ecs, entity_id, hex, def_id) -> void`

Тогда `create_tower` станет:  
`entity_id = ecs.create_entity()` → `positions[entity_id] = ...` → `_apply_tower_components(...)` → `hex_map.place_tower(...)` → `return entity_id`.

**Тесты (шаг 0.1):**

*Важно:* клавиши **1**, **2**, **3** включают **режим отладки** — при каждом клике ставится дебаг-башня (не считается в лимит 5, не временная). **0** — выключить режим отладки.

1. Запусти игру (Start game).
2. **Дебаг-майнер:** нажми **2** (режим TOWER_MINER), кликни по пустому проходимому гексу (лучше на руде). Должна появиться жёлтая шестиугольная башня, в консоли "Placed DEBUG tower ... [NOT COUNTED]".
3. **Дебаг-атакующие:** нажми **1** (RANDOM_ATTACK), поставь 2–3 башни на пустые гексы. Появляются круги/шестиугольники разных цветов, в консоли "Placed DEBUG tower ... [NOT COUNTED]", без ошибок.
4. **Дебаг-стена:** нажми **3**, поставь стену на гекс. Серая шестиугольная стена, снова "Placed DEBUG tower ... [NOT COUNTED]".
5. **Лимит и фаза (обычные башни):** нажми **0**, чтобы выйти из дебаг-режима. Поставь 5 обычных башен подряд (первая по правилу — майнер, остальные из loot table). После 5-й фаза сама переключится на SELECTION (индикатор жёлтый).
6. **Крафт:** в SELECTION выбери две атакующие, при подсветке крафта нажми "Скрафтить". Должна получиться крафтовая башня без падения.
7. **Волна:** перейди в WAVE (Space или клик по индикатору). Дождись врагов, башни стреляют, урон есть, ошибок нет.
8. Если хоть один пункт не так — откати шаг 0.1.

---

## Фаза 1: Данные вместо веток по типу в фабрике

### Шаг 1.1 — Компоненты только по наличию ключей в def

**Где:** `entity_factory.gd` (в `_apply_tower_components` или в `create_tower` до выноса).

**Что сделать:** Не смотреть на `tower_type` для решения «добавлять combat?». Смотреть только: есть ли в `tower_def` ключ `"combat"`. Если есть — добавлять компонент combat из def. Аналогично: если есть ключ `"aura"` — добавлять aura. Для MINER/WALL в JSON нет combat/aura, поэтому ветки по типу можно убрать и оставить только «если в def есть combat — добавить combat».

**Тесты (шаг 1.1):** Поведение не меняется — те же проверки, что и для шага 0.1:
1. Дебаг: **2** → майнер, **1** → 2–3 атакующие, **3** → стена. В консоли без ошибок, башни на месте.
2. **0** → выйти из дебага. Поставить 5 обычных башен → фаза переключается на SELECTION.
3. SELECTION: крафт по подсветке работает.
4. WAVE: враги идут, башни стреляют, урон есть.
Если что-то перестало работать (майнер без энергии, атакующая не стреляет, крафт падает) — откати шаг 1.1.

### Шаг 1.2 — RANDOM_ATTACK из данных ✓

**Где:** `core/systems/input_system.gd`, `_get_random_attack_tower_ids()`.

**Сделано:** Список собирается из `DataRepository.tower_defs`: только `type == "ATTACK"`, **`crafting_level == 0`** (базовые; Silver, Malachite и т.п. не выпадают), и не `no_random`. Кэш при первом вызове.

**Проверка:** Клавиша 1 → только базовые атакующие (TA, TE, TO, PA, PE, PO, DE, NI, NU). Улучшенные башни в рандом не попадают.

---

## Фаза 2: Визуал из данных (опционально, можно позже)

### Шаг 2.1 — Форма башни из def

**Где:** `data/towers.json` — добавить при необходимости поле `visuals.shape` (`"circle"` / `"hex"`).  
**Где:** `godot_adapter/rendering/entity_renderer.gd`, `_create_tower_visual`.

**Что сделать:** Читать форму из `tower_def.visuals.shape`. Если поля нет — использовать текущую логику по умолчанию (MINER/WALL → hex, ATTACK → circle, crafting_level >= 1 → hex). То есть сначала подставить чтение `shape` и fallback на старую логику, не меняя визуала.

**Проверка:** Все башни выглядят как раньше. После этого можно постепенно переносить форму в JSON для части башен.

### Шаг 2.2 — tower_preview

**Где:** `godot_adapter/rendering/tower_preview.gd`.

**Что сделать:** Аналогично — форма превью из `def.visuals.shape` с тем же fallback. Один источник правды: форма в def или дефолт по типу.

**Проверка:** Превью при наведении совпадает с тем, что ставится.

---

## Фаза 3: Пост-создание в одном месте

### Шаг 3.1 — Всё «после постановки башни» в одну функцию

**Где:** `core/systems/input_system.gd`, функция `place_tower`.

**Что сделать:** После `EntityFactory.create_tower(...)` сейчас идёт: авто-выбор майнеров (`is_selected`), `energy_network.add_tower_to_network`, обновление `game_state`, вызов `wall_renderer.force_immediate_update` для стен, `crafting_system.recalculate_combinations`, `update_future_path`. Вынести этот блок в одну функцию, например `_on_tower_placed(tower_id, tower_def_id, hex)` (в input_system или в GameManager, как удобнее). `place_tower` тогда только: проверки → `_determine_tower_id` → `EntityFactory.create_tower` → `_on_tower_placed(...)`.

**Проверка:** Поведение не меняется: майнеры выбираются, энергосеть обновляется, счётчики, стены, крафт, путь.

### Шаг 3.2 — Правило «майнеры auto-selected» из данных (опционально)

**Где:** В `_on_tower_placed` (или там, где ставится `is_selected` для майнеров).

**Что сделать:** Вместо `if tower_def.get("type") == "MINER"` можно проверять `tower_def.get("auto_selected_for_keeping", false)` и в JSON для майнеров добавить `"auto_selected_for_keeping": true`. Так в будущем любую башню можно будет помечать как «выбрана по умолчанию» без нового `if` в коде. Сейчас можно оставить проверку по типу — главное, что логика собрана в одном месте.

**Проверка:** Майнеры по-прежнему автоматически выбраны для сохранения.

---

## Фаза 4: Добавление новых типов (после шагов 0–3)

### Шаг 4.1 — Новая башня только через JSON

**Что сделать:** Добавить в `towers.json` новую башню (например кварц). Заполнить `type`, при необходимости `combat`, `aura`, `visuals` (в т.ч. `shape` если ввели в шаге 2.1). Не добавлять новых `if` в фабрику: фабрика уже вешает combat/aura по наличию ключей в def.

**Проверка:** Поставить новую башню (через лут-таблицу или дебаг), убедиться что создаётся, отображается, энергосеть/комбат не падают. Если у кварца особый тип (не MINER/ATTACK/WALL) — см. шаг 4.2.

### Шаг 4.2 — Особые типы в энергосети и комбате

**Где:** `energy_network_system.gd`, `combat_system.gd` и т.п.

**Что сделать:** Если новый тип (например QUARTZ) должен по-особому участвовать в энергосети или в боевой системе — добавить **минимальную** ветку только там (по `def_id` или `def.type`), не трогая фабрику и рендер. Фабрика по-прежнему только «по def навешиваю компоненты»; особую логику держать в системах.

**Проверка:** Новая башня ведёт себя как задумано, старые башни не затронуты.

---

## Порядок и откат

- Делать шаги **по порядку**. После каждого шага — полная проверка (поставить башни, волна, крафт, энергосеть, стены).
- Если что-то сломалось — откатить только последний шаг (малый объём изменений).
- Фазу 2 (визуал из данных) можно отложить и делать уже когда появятся новые башни с нестандартной формой.
- Фаза 4 — когда будешь реально добавлять кварц, минус-армор и т.д.; к тому моменту фазы 0, 1 и 3 уже снизят риск багов.

---

*Связанные документы: EXTENSION_RISKS.md (где завязано на тип), DEVELOPMENT_PLAN.md (общий план).*
