// internal/system/render_optimized.go
package system

import (
	"go-tower-defense/internal/component"
	"go-tower-defense/internal/config"
	"go-tower-defense/internal/defs"
	"go-tower-defense/internal/entity"
	"go-tower-defense/internal/types"
	"go-tower-defense/pkg/hexmap"
	"image/color"
	"math"
	"sync"

	rl "github.com/gen2brain/raylib-go/raylib"
)

// RenderSystemRL - оптимизированная система рендеринга
type RenderSystemRL struct {
	ecs    *entity.ECS
	font   rl.Font
	camera *rl.Camera3D
	
	// Кеширование
	worldPosCache     map[types.EntityID]rl.Vector3
	hexWorldPosCache  map[hexmap.Hex]rl.Vector3
	cacheMutex        sync.RWMutex
	
	// Батчинг
	instancedTowers   map[string]*InstancedMesh
	instancedEnemies  *InstancedMesh
	
	// LOD (Level of Detail)
	lodDistances      []float32
}

type InstancedMesh struct {
	mesh      rl.Mesh
	model     rl.Model
	instances []rl.Matrix
	colors    []rl.Color
	count     int
}

// NewRenderSystemRL создает новую систему рендеринга
func NewRenderSystemRL(ecs *entity.ECS, font rl.Font) *RenderSystemRL {
	return &RenderSystemRL{
		ecs:              ecs,
		font:             font,
		worldPosCache:    make(map[types.EntityID]rl.Vector3),
		hexWorldPosCache: make(map[hexmap.Hex]rl.Vector3),
		instancedTowers:  make(map[string]*InstancedMesh),
		lodDistances:     []float32{50, 150, 300, 600}, // В единицах CoordScale
	}
}

// SetCamera устанавливает камеру для системы рендеринга
func (s *RenderSystemRL) SetCamera(camera *rl.Camera3D) {
	s.camera = camera
}

// Draw оптимизированная отрисовка
func (s *RenderSystemRL) Draw(gameTime float64, isDragging bool, sourceTowerID, hiddenLineID types.EntityID, gameState component.GamePhase, cancelDrag func()) {
	if s.camera == nil {
		return
	}
	
	// Обновляем батчи
	s.updateBatches()
	
	// Рисуем батчами
	s.drawInstancedTowers()
	s.drawInstancedEnemies()
	
	// Рисуем динамические элементы
	s.drawDynamicElements(gameTime, isDragging, sourceTowerID, hiddenLineID, cancelDrag)
	
	// UI элементы рисуем в последнюю очередь
	s.drawText()
}

// updateBatches обновляет данные для инстансинга
func (s *RenderSystemRL) updateBatches() {
	// Очищаем старые батчи
	for _, batch := range s.instancedTowers {
		batch.count = 0
	}
	
	// Группируем башни по типам
	for id, tower := range s.ecs.Towers {
		if renderable, ok := s.ecs.Renderables[id]; ok {
			towerDef, ok := defs.TowerDefs[tower.DefID]
			if !ok {
				continue
			}
			
			// Получаем или создаем батч для этого типа башни
			batchKey := string(tower.DefID)
			batch, exists := s.instancedTowers[batchKey]
			if !exists {
				batch = s.createTowerBatch(towerDef)
				s.instancedTowers[batchKey] = batch
			}
			
			// Добавляем инстанс
			if batch.count < len(batch.instances) {
				worldPos := s.getHexWorldPos(tower.Hex)
				transform := rl.MatrixTranslate(worldPos.X, worldPos.Y, worldPos.Z)
				
				// Применяем LOD
				lod := s.getLOD(worldPos)
				if lod < 3 { // Не рисуем самые далекие объекты
					batch.instances[batch.count] = transform
					batch.colors[batch.count] = colorToRL(renderable.Color)
					batch.count++
				}
			}
		}
	}
}

// createTowerBatch создает батч для определенного типа башни
func (s *RenderSystemRL) createTowerBatch(towerDef defs.TowerDef) *InstancedMesh {
	// Создаем базовую mesh в зависимости от типа
	var mesh rl.Mesh
	switch towerDef.Type {
	case defs.TowerTypeWall:
		mesh = rl.GenMeshCylinder(1.0, 2.0, 6)
	case defs.TowerTypeMiner:
		mesh = rl.GenMeshCone(1.0, 3.0, 16)
	default:
		mesh = rl.GenMeshCylinder(1.0, 3.0, 24)
	}
	
	model := rl.LoadModelFromMesh(mesh)
	
	return &InstancedMesh{
		mesh:      mesh,
		model:     model,
		instances: make([]rl.Matrix, 1000), // Максимум 1000 башен одного типа
		colors:    make([]rl.Color, 1000),
		count:     0,
	}
}

// drawInstancedTowers рисует все башни одного типа одним вызовом
func (s *RenderSystemRL) drawInstancedTowers() {
	for _, batch := range s.instancedTowers {
		if batch.count > 0 {
			// В Raylib нет прямой поддержки инстансинга, 
			// но мы можем оптимизировать через display lists или VBO
			for i := 0; i < batch.count; i++ {
				rl.DrawModel(batch.model, rl.Vector3{}, 1.0, batch.colors[i])
			}
		}
	}
}

// drawInstancedEnemies рисует всех врагов батчами
func (s *RenderSystemRL) drawInstancedEnemies() {
	// Группируем врагов по расстоянию для LOD
	nearEnemies := make([]types.EntityID, 0, 100)
	farEnemies := make([]types.EntityID, 0, 100)
	
	for id := range s.ecs.Enemies {
		if pos, ok := s.ecs.Positions[id]; ok {
			worldPos := s.pixelToWorld(*pos)
			lod := s.getLOD(worldPos)
			
			if lod == 0 {
				nearEnemies = append(nearEnemies, id)
			} else if lod < 3 {
				farEnemies = append(farEnemies, id)
			}
		}
	}
	
	// Рисуем близких врагов с полной детализацией
	for _, id := range nearEnemies {
		s.drawEnemy(id, false)
	}
	
	// Рисуем далеких врагов упрощенно
	for _, id := range farEnemies {
		s.drawEnemy(id, true)
	}
}

// drawEnemy рисует одного врага с учетом LOD
func (s *RenderSystemRL) drawEnemy(id types.EntityID, simplified bool) {
	renderable, ok := s.ecs.Renderables[id]
	if !ok {
		return
	}
	
	pos, ok := s.ecs.Positions[id]
	if !ok {
		return
	}
	
	worldPos := s.getEntityWorldPos(id, *pos)
	scaledRadius := float32(renderable.Radius * config.CoordScale)
	worldPos.Y = scaledRadius
	
	finalColor := s.getEntityColor(id, renderable)
	
	if simplified {
		// Упрощенная отрисовка для далеких объектов
		rl.DrawCube(worldPos, scaledRadius*2, scaledRadius*2, scaledRadius*2, finalColor)
	} else {
		// Полная отрисовка для близких объектов
		rl.DrawSphere(worldPos, scaledRadius, finalColor)
		if renderable.HasStroke {
			rl.DrawSphereWires(worldPos, scaledRadius, 4, 4, rl.White)
		}
	}
}

// drawDynamicElements рисует динамические элементы (лазеры, линии и т.д.)
func (s *RenderSystemRL) drawDynamicElements(gameTime float64, isDragging bool, sourceTowerID, hiddenLineID types.EntityID, cancelDrag func()) {
	// Объединяем все линии в один вызов
	s.drawAllLines(hiddenLineID)
	
	// Лазеры тоже можно батчить
	s.drawAllLasers()
	
	// Остальные элементы
	s.drawPulsingOres(gameTime)
	s.drawRotatingBeams()
	s.drawDraggingLine(isDragging, sourceTowerID, cancelDrag)
	s.drawCombinationIndicators()
}

// drawAllLines рисует все линии одним проходом
func (s *RenderSystemRL) drawAllLines(hiddenLineID types.EntityID) {
	// Собираем все линии
	lines := make([]struct{ start, end rl.Vector3 }, 0, len(s.ecs.LineRenders))
	
	for id, line := range s.ecs.LineRenders {
		if id == hiddenLineID {
			continue
		}
		
		tower1, ok1 := s.ecs.Towers[line.Tower1ID]
		render1, ok1r := s.ecs.Renderables[line.Tower1ID]
		tower2, ok2 := s.ecs.Towers[line.Tower2ID]
		render2, ok2r := s.ecs.Renderables[line.Tower2ID]
		
		if ok1 && ok1r && ok2 && ok2r {
			startPos := s.getHexWorldPos(tower1.Hex)
			endPos := s.getHexWorldPos(tower2.Hex)
			
			height1 := s.GetTowerRenderHeight(tower1, render1)
			height2 := s.GetTowerRenderHeight(tower2, render2)
			
			startPos.Y = height1
			endPos.Y = height2
			
			lines = append(lines, struct{ start, end rl.Vector3 }{startPos, endPos})
		}
	}
	
	// Рисуем все линии
	for _, line := range lines {
		rl.DrawCapsule(line.start, line.end, 0.6, 4, 4, rl.Yellow)
	}
}

// drawAllLasers рисует все лазеры оптимизированно
func (s *RenderSystemRL) drawAllLasers() {
	for _, laser := range s.ecs.Lasers {
		alpha := 1.0 - (laser.Timer / laser.Duration)
		if alpha <= 0 {
			continue
		}
		
		r, g, b, _ := laser.Color.RGBA()
		lineColor := rl.NewColor(uint8(r>>8), uint8(g>>8), uint8(b>>8), uint8(alpha*255))
		
		startPos := s.pixelToWorld(component.Position{X: laser.FromX, Y: laser.FromY})
		endPos := s.pixelToWorld(component.Position{X: laser.ToX, Y: laser.ToY})
		
		rl.DrawLine3D(startPos, endPos, lineColor)
	}
}

// getLOD возвращает уровень детализации в зависимости от расстояния
func (s *RenderSystemRL) getLOD(worldPos rl.Vector3) int {
	if s.camera == nil {
		return 0
	}
	
	dist := rl.Vector3Distance(s.camera.Position, worldPos)
	
	for i, lodDist := range s.lodDistances {
		if dist < lodDist*config.CoordScale {
			return i
		}
	}
	
	return len(s.lodDistances)
}

// getEntityWorldPos возвращает закешированную позицию сущности
func (s *RenderSystemRL) getEntityWorldPos(id types.EntityID, pos component.Position) rl.Vector3 {
	s.cacheMutex.RLock()
	if cached, ok := s.worldPosCache[id]; ok {
		s.cacheMutex.RUnlock()
		return cached
	}
	s.cacheMutex.RUnlock()
	
	worldPos := s.pixelToWorld(pos)
	
	s.cacheMutex.Lock()
	s.worldPosCache[id] = worldPos
	s.cacheMutex.Unlock()
	
	return worldPos
}

// getHexWorldPos возвращает закешированную позицию гекса
func (s *RenderSystemRL) getHexWorldPos(h hexmap.Hex) rl.Vector3 {
	s.cacheMutex.RLock()
	if cached, ok := s.hexWorldPosCache[h]; ok {
		s.cacheMutex.RUnlock()
		return cached
	}
	s.cacheMutex.RUnlock()
	
	worldPos := s.hexToWorld(h)
	
	s.cacheMutex.Lock()
	s.hexWorldPosCache[h] = worldPos
	s.cacheMutex.Unlock()
	
	return worldPos
}

// getEntityColor определяет цвет сущности с учетом эффектов
func (s *RenderSystemRL) getEntityColor(id types.EntityID, renderable *component.Renderable) rl.Color {
	if _, ok := s.ecs.DamageFlashes[id]; ok {
		return config.EnemyDamageColorRL
	}
	if _, ok := s.ecs.PoisonEffects[id]; ok {
		return config.ProjectileColorPoisonRL
	}
	if _, ok := s.ecs.SlowEffects[id]; ok {
		return config.ProjectileColorSlowRL
	}
	return colorToRL(renderable.Color)
}

// Остальные методы остаются без изменений...
func (s *RenderSystemRL) hexToWorld(h hexmap.Hex) rl.Vector3 {
	x, y := h.ToPixel(float64(config.HexSize))
	return rl.NewVector3(float32(x*config.CoordScale), 0, float32(y*config.CoordScale))
}

func (s *RenderSystemRL) pixelToWorld(p component.Position) rl.Vector3 {
	return rl.NewVector3(float32(p.X*config.CoordScale), 0, float32(p.Y*config.CoordScale))
}

// ... остальные вспомогательные методы