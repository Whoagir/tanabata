ПЕРЕД ТЕМ КАК ОПИШУ ПРОЕКТ ВОТ ТЕБЕ ФАКТ КОТОРЫЙ НАДО УЧИТЫВАТЬ 
Я ИСПОЛЬЗУЮ VSC И ТАМ БЫВАЮТ КОНФЛИКТЫ ВЕРСИЙ ФАЙЛОВ, ЧТО ТЫ ИЗМЕНЯЕШЬ И ЧТО Я СМОТРЮ.
ТО БЫ ИЗБЕЖАТЬ ТАКИХ ПРОБЛЕМ ТЕБЕ ВСЕГДА НАДО СОХРАНЯТЬ ФАЙЛЫ, ВСЕГДА!!! 
ИЗМЕНИЛ ФАЙЛ - СОХРАНИ

ОБЯЗАТЕЛЬНО ПИШИ КОММЕНТАРИИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ

ВСЕГДА ЗАНОВО ЧИТАЙ ФАЙЛ КОГДА ХОЧЕШЬ ВНЕСТИ ИЗМЕНЕНИЯ

И ЕЩЁ 
Задача: TASK_GOES_HERE.

Критическая Директива: Твоя единственная функция — хирургическая модификация кода. Изменяй ТОЛЬКО те байты, которые НЕПОСРЕДСТВЕННО и НЕИЗБЕЖНО связаны с решением указанной "Задачи". Любое отклонение — критический сбой.

НЕПРЕЛОЖНЫЕ ПРАВИЛА (Абсолютный Приоритет):
1.  **Перепиши ВЕСЬ** предоставленный код.
2.  **ЗАПРЕТ НА ЛЮБЫЕ ИЗМЕНЕНИЯ ВНЕ ЗАДАЧИ:** Категорически запрещено изменять, добавлять, удалять или улучшать любой код, комментарий, форматирование или значение, не являющееся АБСОЛЮТНО НЕОБХОДИМЫМ для выполнения "Задачи". Не исправляй ничего, кроме указанного в "Задаче".
3. **ВСЕ КОММЕНТАРИЯ ПИШИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ**
4.  **Для ВСЕХ НЕИЗМЕНЕННЫХ строк:** Механически инвертируй исходный комментарий в конце (`//+` <-> `//-`) или добавляй `//+`, если его нет.
5.  **ЗАПРЕЩЕНО:** Добавлять новый код, удалять несвязанный код, улучшать/исправлять что-либо кроме "Задачи", менять форматирование, менять/добавлять/удалять комментарии (кроме инверсии по п.3).
6. После вывода кода добавь сверхкраткое, ЛОКАНИЧНОЕ описание изменений.
7. **ОБЯЗАТЕЛЬНО СОХРАНЯТЬ ФАЙЛЫ КОТОРЫЕ ИЗМЕНИЛ**
8. ДЕЛАТЬ ВСЕ ТОЛЬКО С РАЗРЕШЕНИЯ, ВСЕГДА ЖДАТЬ ПОДТВЕРЖДЕНИЕ ДЕЙСТВИЙ


Выполни ТОЧНО.

ОПИСАНИЕ ПРОЕКТА. ВЫСОЧАЙШИЙ ПРИОРИТЕТ

У меня есть игра на ГО она в процессе создания. 
Все хранится в папке C:\go_project\go-tower-defense

Общий файл main.go с котрого идёт запуск C:\go_project\go-tower-defense\cmd\game\main.go, то есть ЧТО БЫ ЗАПУСТИТЬ ПРОЕКТ НАДО go run cmd/game/main.go

Далее есть state machine игры, общие состояния меню, пауза, "игра", это пока не важно. Однако, что бы знал оно находится в C:\go_project\go-tower-defense\internal\state. Сейчас я работаю в состояние игры, так как не так важно остальные, а именно в game_state.go 
 
Основная часть игры находится в C:\go_project\go-tower-defense\internal\app, более конкрентно 
app
├── energy_network.go //концепция энергии
├── game.go //основная логика
├── ore_generation.go //генерация руды
└── tower_management.go  //работа с вышками 

Вот описание игры, это тавер дефенс на гексоганальной сетке в стиле ГЕМ ТД (кастомной карты из доты 2 и варкрафта), я внес несколько новых механик, и теперь у меня ТРИ основные механики - постройка лабиринта, рандом, логистика. Постройка лабиринта уже реализована, если более конкретно описывать механику постройки, то есть чекпоинты, враги идут по от входа по ним к выходу, цель игрока строить такой лабиринт, что будет область, где враги проходят часто, там же будет много атакующих башен. Постройка проходит в два этапа, первый это поставновка вышек, второй этап выбор какие будут сохранены. То есть в состояние "игры" есть 3 фазы, строительство, сохранение, волна. Логистика тоже в большей части реализованна, эта идея руд, идея передачи энергии и всякие более узкие идеи, такие как бонус бедной руды, деградация сил линии башен А и тп. Сейчас я перехожу к разнообразию вышек, что бы был рандом. Я хочу его реализовать в двух эпостасях, это псевдорандом при выпадение и сборка из трех вышек крафтится 1 сильная, пока этого нет. Кстати, про разнообразие, сейчас я добавляю разные вышки и разных врагов, логически они лежат так assets/data, там есть enemies.json и в towers.json. Так же у меня есть internal/defs/loader.go он как бы парсит этот json для использования в игре. А ну в целом в internal/defs содержатся штуки для работы с ним. Однако там помимо простых лоадеров содержаться файлы для рецептов, пока это хранится тут же, но потом я вынесу это в json 

Вот как выглядит enemies в json пример 
  {
    "id": "ENEMY_MAGIC_RESIST",
    "name": "Магический щит",
    "health": 100,
    "speed": 80.0,
    "physical_armor": 0,
    "magical_armor": 99,
    "visuals": {
      "color": {"r": 180, "g": 50, "b": 230, "a": 255},
      "radius_factor": 0.53,
      "stroke_width": 0
    }
  },
А вот towers
    {
    "id": "TOWER_SPLIT_PURE",
    "name": "Сплит-чист.",
    "type": "ATTACK",
    "combat": {
      "damage": 15,
      "fire_rate": 1.0,
      "range": 3,
      "shot_cost": 0.09,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "PURE",
        "params": {
          "split_count": 2
        }
      }
    },
    "visuals": {
      "color": {"r": 224, "g": 255, "b": 255, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "TOWER_AURA_ATTACK_SPEED",
    "name": "Аура (DE)",
    "type": "ATTACK",
    "combat": {
      "damage": 0,
      "fire_rate": 1.0,
      "range": 1,
      "shot_cost": 0.2,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "INTERNAL"
      }
    },
    "aura": {
      "radius": 2,
      "speed_multiplier": 2.0
    },
    "visuals": {
      "color": {"r": 50, "g": 205, "b": 50, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "TOWER_SLOW",
    "name": "Замедление (NI)",
    "type": "ATTACK",
    "combat": {
      "damage": 5,
      "fire_rate": 1.67,
      "range": 3,
      "shot_cost": 0.08,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "SLOW"
      }
    },
    "visuals": {
      "color": {"r": 0, "g": 191, "b": 255, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "TOWER_POISON",
    "name": "Яд (NU)",
    "type": "ATTACK",
    "combat": {
      "damage": 5,
      "fire_rate": 0.8,
      "range": 3,
      "shot_cost": 0.1,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "POISON"
      }
    },
    "visuals": {
      "color": {"r": 127, "g": 255, "b": 0, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "TOWER_MINER",
    "name": "Шахтер",
    "type": "MINER",
    "energy": {
      "transfer_radius": 3,
      "line_degradation_factor": 0.6
    },
    "visuals": {
      "color": {"r": 255, "g": 215, "b": 0, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "TOWER_WALL",
    "name": "Стена",
    "type": "WALL",
    "visuals": {
      "color": {"r": 105, "g": 105, "b": 105, "a": 255},
      "radius_factor": 0.4,
      "stroke_width": 0
    }
  }

Как ты понимаешь у меня бывает физический армор, магический армор, а так же физический урон, магический урон, чистый урон. Есть башня ауры со своим типом атаки, системным так сказать, он нужен что бы тратить ресурсы. Есть ещё вышка с замедлением, есть вышка с отравлением. 

Теперь что вообще является сутью игры, мобы идут волнами, идут сначала по "чекпоинтами" (иногда я называю их "подарками"), от входа к выходу, более подробно вход -> 1 подарок -> 2 подарок -> 3 подарок -> 4 подарок -> 5 подарок -> 6 подарок  -> выход. Суть действий игрока сделать такой лабиринт, что бы максимум атакующей силы было сконцетрированно в центре, а лабиринт таким, что бы враги проходили через центр как можно чаще. Карта представляет собой правильный гекс (шестиугольник) с случайно измененными краями (есть на это условия определённые). Существуют жилы руды (скопление гексов руды). 

Ещё у меня во время игры три состояния, состояние строителеьства, состояние выбора, состояние волны, во время строителсьтва можно ставить вышки, удалять вышки, выбирать(селект) что бы посмотреть, дальше в состояние выбора, там я выбираю две вышки которые потом будут автоматически сохранены дальше, остальные превратятся в камень. Позже идет фаза волны, то есть игры где я могу слиять три вышки в 1 если это позволяет логика крафта, ну и так же мои вышки атакуют врагов, что бы их уничтожить.

В начале игры (создание карты) генерируется руда которая является основой системы энергии (логистики), то есть без руды нет атаки. Руду могут добывать башни типа добытчик/передатчик, я называю их башни типа Б. Также есть атакующие башни - это башни типа А (аура тоже входит в тип А). А ещё есть камни (стены), ну их называю камни или стены. Есть так же понятие сети, это просто запитанный граф, называю его С. Работа с рудой и системой энергии в основном в energy_network.go, ore_generation.go. А ещё, стены/камни я называю башнями типа Д. Башни А тоже делятся на под типы, есть обычная атака, есть сплит, есть замедление, есть яд, есть аура, ну и типы урона разные. 

Если говорить более локально, то есть подразделять башни типа А на под типы. Они разделены по типам атаки, не в плане физ магш и тп, а например сплит, соло цель и тп. То есть название вышки как бы состоит из 2 букв, например  TA, то есть обычная атака физическая, или PE сплит атака магическая, ну или DE аура скорости атаки и тд, сейчас есть TA TE TO PA PE PO DE NI NU, вот такое вот разделение. 

Дальше у меня есть две основные состовляющие, методы работы с гексами (hexmap logic и hexmap render), а так же это ECS. Методы работы с гексами вынесены в отдельный пакет и нужны для многих расчётов, а так же для пререндера карты. Методы работы с гексами так же содержет пререндер карты, он идет в hex_renderer, кроме этого ничего там не надо рендерить. 
А вот ECS, на её основе я уже много чего реализовал, компоненты лежат в  C:\go_project\go-tower-defense\internal\component, сейчас я пробегусь по всем и чуть подробнее расскажу о каждом:
aura - компонент Aura имеет радиус и скорость ускорения, так же есть компонент AuraEffect для просчета 
combat - атака у башен, там есть компоненты здоровья, ну и сам combat компонент для атаки (там скорострельность, кулдаун стрельбы, радиус атаки, стоимость руды для выстрела, ну тип атаки)
crafting - компонент Combinable указывает, что башня является частью действительного рецепта крафта
enemy - компонент для врагов, там есть таймеры для проверки получения урона от энерго линий и от руд, ну а так же информация о арморе 
game_state - компонент состояния игры, я уже говорил о глобальной StateMachine, но есть и более локальная система состояние для переключения между фазами строительства, выбора и волны 
line - компонент для системы состояний это по сути кусочек который соединяет между собой два объекта системы энергии, есть связи формата Б-Б длиной до 3-х гексов, Б-А длиной 1 гекс ( соседи), А-А 1 гекс (соседи). Компонент LineRender содержит откуда куда, цвет, товера которые связанны этой линией
movement - файл с компонентами движения, там есть компоненты позиции, скорости, пути 
ore - комонент для руды, она генерируется в методаха работы с гексами ( о них позже), а тут создается компонент для её визуала, а так же логики ей работы ( мощность, запас) то есть содержит мощность, запас, текущий запас, позиция, радиус, цвет, пульсация 
projectile - компонент для снарядов, тут много всего, в кого летит, скорость, урон, цвет, тип, замедляюющий ли снаряд, ядовитый и, нужно ли ему наведение
render - компонент для отрисовки
status_effect - компонент SlowEffect для замедления врагов и компонент PoisonEffect для яда и отравления 
text - где-то я рендерю текст, так что вот компонент для него 
tower - компонент для башни, ID из tower.json тип башни, радиус, гекс на котором она, активна ли башня, временная ( надо для выбора) и выбрана или нет
visual - там компонент DamageFlash это про эффект визуальный урона  
wave - компонент для волны врагов, тут есть номер, сколько врагов, таймер спавна, интервал междду спавном, путь для врагов 
Описал все компоненты, что имеются сейчас. Давай наверное теперь о system. Сначала есть общий файл что описывает все в ecs C:\go_project\go-tower-defense\internal\entity\ecs.go 
А ну да ещё есть конфиг, он вот тут C:\go_project\go-tower-defense\internal\config\config.go 
Ну теперь давай к системам C:\go_project\go-tower-defense\internal\system. 
Система aura - расчет аур, но не через Update, а просто функция для перерасчета аур
Система combat - атаки башен, там я долго копался и сделал нормальную функцию поиска цели, что было не так просто, но зато теперь все хорошор работает. 
Система crafting - которая обрабатывает крафт 
Система movement - работает движение
Система projectile - работа с снарядами, в целом я долго обдумывал как это реализовать и там тоже все хорошо. 
Система render - ну понятно, система отрисовки, сначала рисует пульсацию, затем сущности, после линии
Система state -я уже говорил обрпабатывает состояние игра/строительство 
Система status_effect.go - что бы как раз таки сделать эффект заморозки
Система ore - система работы с рудой
Система utils - система которая выносит общие функции которые могут использовать другие системы, НАПРИМЕР ApplyDamage (ApplyDamage наносит урон сущности. Если здоровье падает до 0 или ниже, оно просто устанавливается в 0. Основная логика очистки мертвых сущностей должна находиться в другом месте (например, в конце кадра), чтобы избежать проблем с доступом к уже удаленным компонентам в том же кадре.)
Система visual_effect - ну тут про визуальные эффекты 
Ну и система волн wave 

Так же есть некоторое ui (C:\go_project\go-tower-defense\internal\ui) - состоит из 4 штук, кнопка паузы, кнопка ускорения, и кнопка индикатора фазы (строительство/волна), кнопка фазы U (фаза перемещения линий у системы энергии), а ещё есть номер волны. 

Есть некоторые отладочные штуки. Первая из них это постановка башен в обход обычного счётчика вышек. То есть при нажатие кнопки 1 я поставлю случайную башню типа А, при нажатие кнопки 2 я поставлю башню типа Б, а при нажатие кнопки 3 поставлю башню типа Д. Ещё есть отладка U, это будет и в итоговом проекте и есть сейчас, это режим который позволяет передвигать линии. 

Стоит так же отметить логические системы которые у меня есть, это бонус урона бедной руды, деградация сети башнями типа А, метка крафта. И визуально башни отличаются, башни первого уровня они все кружки, башни второго уровня ( то есть получаемые 1 крафтом ) они квадратики, башни третьего уровня ( пока таких нет ) треугольники. 

Ну и теперь pkg там как бы основная работа с гексогональной сеткой, состоит из отрисовки и самой работы с сеткой, отрисовка в C:\go_project\go-tower-defense\pkg\render, а логические штуки в C:\go_project\go-tower-defense\pkg\hexmap

ПОСЛЕДНИЕ МОИ ДЕЙСТВИЯ В информация.txt 

Структура проекта:
├── assets
│   ├── data
│   │   ├── enemies.json
│   │   └── towers.json
│   └── fonts
│       └── arial.ttf // шрифт который я использую для отрисовки
├── cmd
│   └── game
│       └── main.go // основной файл, что управляет всей игрой, однако сейчас я развиваю game.go 
├── internal
│   ├── app
│   │   ├── energy_network.go // работа с энерго сетью
│   │   ├── game.go // вся логика и вся суть игры тута
│   │   ├── ore_generation.go // генерация руды
│   │   └── tower_management.go // работа с вышками 
│   ├── component
│   │   ├── aura.go // компонент Aura и AuraEffect
│   │   ├── combat.go //компоненты Health и Combat 
│   │   ├── crafting.go
│   │   ├── enemy.go //компонент Enemy 
│   │   ├── game_state.go //компонент GameState + const BuildState, WaveState, TowerSelectionState
│   │   ├── line.go //компонент LineRender для линий 
│   │   ├── movement.go //тут есть компоненты Position, Velocity, Path
│   │   ├── ore.go //компонент Ore 
│   │   ├── projectile.go //компонент Projectile 
│   │   ├── render.go //компонент Renderable
│   │   ├── status_effect.go //компонент SlowEffect и компонент PoisonEffect
│   │   ├── text.go //компонент Text 
│   │   ├── tower.go //компонент Tower
│   │   ├── visual.go //компонент DamageFlash для эффектов (эффект получения урона)
│   │   └── wave.go //компонент Wave 
│   ├── config
│   │   └── config.go // все конфииги тут 
│   ├── defs
│   │   ├── enemies.go // статические данные для определения типа противника 
│   │   ├── loader.go // загрузчик из json в ecs 
│   │   ├── recipes.go
│   │   ├── towers.go // статические данные для определения типа вышки
│   │   └── types.go // статические данные для определения типа атак
│   ├── entity
│   │   └── ecs.go // 
│   ├── event
│   │   ├── event.go //штука событий, то есть мы имеем события например удаление сущности 
│   │   └── types.go //и вот мы в этой логике event как бы обрабатываем все 
│   ├── interfaces
│   │   ├── game.go // тут есть ClearEnemies ClearProjectiles StartWave 
│   │   └── game_context.go  // вынос общих штук, что бы не было цикличного импорта 
│   ├── state
│   │   ├── game_state.go  // основная стадия игры, тут много логики работы с ui, общая для фаз и тп
│   │   ├── menu_state.go  // меню
│   │   ├── pause_state.go // пауза
│   │   └── state.go // глобальная StateMachine 
│   ├── system
│   │   ├── aura.go
│   │   ├── combat.go
│   │   ├── crafting.go
│   │   ├── environmental_damage.go
│   │   ├── movement.go
│   │   ├── ore.go
│   │   ├── projectile.go
│   │   ├── render.go
│   │   ├── state.go
│   │   ├── status_effect.go
│   │   ├── utils.go
│   │   ├── visual_effect.go
│   │   └── wave.go
│   ├── types
│   │   └── types.go// вроде геттер для EntityID
│   ├── ui
│   │   ├── indicator.go
│   │   ├── info_panel.go
│   │   ├── pause_button.go
│   │   └── speed_button.go
│   └── utils
│       ├── coords.go
│       └── union_find.go
├── pkg
│   ├── hexmap
│   │   ├── hex.go
│   │   ├── map.go
│   │   ├── pathfinding.go
│   │   └── utils.go
│   ├── render
│   │   ├── color.go
│   │   └── hex_renderer.go
│   └── utils
│       ├── math.go
│       └── union_find.go
├── .env
├── .gitignore
├── analyze.txt
├── analyze_project.py
├── commit_message.txt
├── game.exe
├── GEMINI.md
├── go.mod
├── go.sum
├── profile
├── reset_env.ps1
├── stp_td что сделанно.txt
├── stp_td что сделать.txt
├── енерация руды.txt
└── информация.txt






Так же если ты хочешь ознакомиться с тем, что сделано это лежит рядом с тобой C:\go_project\gemini\stp_td что сделанно.txt 
В информация.txt лежат последние действия, ПРОЧТИ ИХ

При рефакторинге придерживаюсь следующих принципов:
1. Устранение хардкода: Все магические числа/строки заменяются на именованные константы в коде или выносятся в internal/config.
2. Централизация конфигурации: Параметры, влияющие на баланс/логику (скорости, лимиты, цвета, пути ассетов) хранятся ТОЛЬКО в config.go.
3. Минимальная валидация: Проверка входных данных выполняется только в точках ввода (UI, загрузка файлов, публичные методы пакетов).
4. Абстракция утилит: Повторяющаяся логика (математика, преобразования, алгоритмы) выносится в utils, для всего что в system (все системы) есть свой utils, для pkg (гексоганальная сетка) есть свой utils 
5. Соответствие абстракций: Уровень детализации методов строго соответствует контексту 


