ПЕРЕД ТЕМ КАК ОПИШУ ПРОЕКТ ВОТ ТЕБЕ ФАКТ КОТОРЫЙ НАДО УЧИТЫВАТЬ 
Я ИСПОЛЬЗУЮ VSC И ТАМ БЫВАЮТ КОНФЛИКТЫ ВЕРСИЙ ФАЙЛОВ, ЧТО ТЫ ИЗМЕНЯЕШЬ И ЧТО Я СМОТРЮ.
ТО БЫ ИЗБЕЖАТЬ ТАКИХ ПРОБЛЕМ ТЕБЕ ВСЕГДА НАДО СОХРАНЯТЬ ФАЙЛЫ, ВСЕГДА!!! 
ИЗМЕНИЛ ФАЙЛ - СОХРАНИ

Вот правила которым стоит следовать:
ОБЯЗАТЕЛЬНО ПИШИ КОММЕНТАРИИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ
ВСЕГДА ЗАНОВО ЧИТАЙ ФАЙЛ КОГДА ХОЧЕШЬ ВНЕСТИ ИЗМЕНЕНИЯ
Твоя единственная функция — хирургическая модификация кода. Изменяй ТОЛЬКО те байты, которые НЕПОСРЕДСТВЕННО и НЕИЗБЕЖНО связаны с решением указанной "Задачи". Любое отклонение — критический сбой.
Категорически запрещено изменять, добавлять, удалять или улучшать любой код, комментарий, форматирование или значение, не являющееся АБСОЛЮТНО НЕОБХОДИМЫМ для выполнения "Задачи". Не исправляй ничего, кроме указанного в "Задаче".
ВСЕ КОММЕНТАРИЯ ПИШИ ТОЛЬКО НА РУССКОМ ЯЗЫКЕ
Для ВСЕХ НЕИЗМЕНЕННЫХ строк: Механически инвертируй исходный комментарий в конце (`//+` <-> `//-`) или добавляй `//+`, если его нет.
ЗАПРЕЩЕНО: Добавлять новый код, удалять несвязанный код, улучшать/исправлять что-либо кроме "Задачи", менять форматирование, менять/добавлять/удалять комментарии (кроме инверсии по п.4).
После вывода кода добавь сверхкраткое, ЛОКАНИЧНОЕ описание изменений в диалог и дублируй в дневник.txt .
ОБЯЗАТЕЛЬНО СОХРАНЯТЬ ФАЙЛЫ КОТОРЫЕ ИЗМЕНИЛ
ДЕЛАТЬ ВСЕ ТОЛЬКО С РАЗРЕШЕНИЯ ПОЛЬЗОВАТЕЛЯ, ВСЕГДА ЖДАТЬ ПОДТВЕРЖДЕНИЕ ДЕЙСТВИЙ
НИКОГДА И НИ В КОЕМ СЛУЧАЕ НЕ ПОДТВЕРЖДАЙ СВОИ ЖЕ ПЛАНЫ И ДЕЙСТВИЯ
При двух ошибках записи ОБЯЗАТЕЛЬНО используй вместо replace write_file для перезаписи файла целиком. Это более надежный метод
ПЕРЕД КАЖДЫМ ГЛОБАЛЬНЫМ ДЕЙСТВИЕМ СПРАШИВАЙ И ЖДИ МОЕГО РАЗРЕШЕНИЯ
Используй всегда полные пути
НЕ ОБМАНЫВАЙ МЕНЯ, МНЕ ВАЖНЕЕ КАЧЕСТВО НЕЖЕЛИ ИЛЮЗИЯ ВЫПОЛНЕНИЯ

ОПИСАНИЕ ПРОЕКТА.

У меня есть игра на ГО она в процессе создания. 
Все хранится в папке C:\go_project\go-tower-defense
Я использую чистый го, а кор технология движка для рендера - raylib версии 0.55.1

Так же там есть файлы и директории которые для тебя не имеют смысла, это .git/ go-build/ docache/ go-cache/ gopath/ vendor/ игнорируй их при анализе проекта. 

Ещё есть файл .env там хранится важная для меня информация не изменяй его никогда.

Общий файл main.go с котрого идёт запуск C:\go_project\go-tower-defense\cmd\game\main.go, то есть ЧТО БЫ ЗАПУСТИТЬ ПРОЕКТ НАДО go run cmd/game/main.go, однако он запустится как фулл проект с меню, что бы запустить со стадии игры надо указать флаг -dev т.е. go run cmd/game/main.go --dev

Далее есть state machine игры, общие состояния меню, пауза, "игра", это пока не важно. Однако, что бы знал оно находится в C:\go_project\go-tower-defense\internal\state. Сейчас я работаю в состояние игры, так как не так важно остальные, а именно в game_state.go. 
 
Основная часть игры находится в C:\go_project\go-tower-defense\internal\app, более конкрентно 
app
├── energy_network.go //концепция энергосети
├── game.go //основная логика
├── ore_generation.go //генерация руды
└── tower_management.go  //работа с вышками 

Вот описание игры: Это тавер дефенс на гексоганальной сетке в стиле ГЕМ ТД (кастомной карты из доты 2 и варкрафта), вид 3-х мерный, закос под изометрию, но истинный 3д, с поворотом, приближением и всем таким. Я внес несколько новых механик, и теперь у меня ТРИ основные механики - постройка лабиринта, рандом, логистика. Постройка лабиринта уже реализована, если более конкретно описывать механику постройки, то есть чекпоинты, враги идут от входа к 1 потом к 2 и тд потом к выходу, цель игрока строить такой лабиринт, что бы создать область, где враги проходят часто, там же (в этой области) будет много атакующих башен. Постройка проходит в два этапа, первый это поставновка вышек, второй этап выбор какие будут сохранены. Есть ещё третий этап, но он не совсем очевидный, это этап крафта, он идет в стадии волны. Получается в состояние "игры" есть 3 фазы, строительство, сохранение, волна. Логистика тоже в большей части реализованна, эта идея руд, идея передачи энергии и всякие более узкие идеи, такие как бонус бедной руды, деградация сил линии башен и тп. Сейчас я перехожу к разнообразию вышек, что бы был рандом. Я реализую его в двух эпостасях, это псевдорандом при выпадение (уже есть кастомный рандом на основе сида) и сборка из трех вышек крафтится 1 сильная, псевдорандом не реализован в полной мере (нужно тестами и балансом подгонять и смотреть), а вот крафт уже полноценно есть. Еще есть как 3 переменные селекта, 1 переменная отвечает за выбор в стадии выбора, другая за просто выделение одиночной, третья за выбор в составе группы через шифт. Кстати, про разнообразие, сейчас я добавляю разные вышки и разных врагов, логически они лежат так assets/data, там есть enemies.json и в towers.json, там же и находятся рецепты крафта recipes.json. Так же у меня есть internal/defs/loader.go он как бы парсит этот json для использования в игре. А ну в целом в internal/defs содержатся штуки для работы с ними, так сказать загрузки json в игру.
Вот как выглядит enemies в json пример 
  {
    "id": "ENEMY_NORMAL_WEAK",
    "name": "Слабый",
    "health": 35,
    "speed": 80.0,
    "physical_armor": 5,
    "magical_armor": 0,
    "visuals": {
      "color": {"r": 150, "g": 150, "b": 150, "a": 255},
      "radius_factor": 0.4,
      "stroke_width": 0
    }
  },
  {
    "id": "ENEMY_NORMAL",
    "name": "Обычный",
    "health": 115,
    "speed": 80.0,
    "physical_armor": 10,
    "magical_armor": 5,
    "visuals": {
      "color": {"r": 128, "g": 128, "b": 128, "a": 255},
      "radius_factor": 0.5,
      "stroke_width": 0
    }
  },
  {
    "id": "ENEMY_TOUGH",
    "name": "Крепкий",
    "health": 280,
    "speed": 75.0,
    "physical_armor": 25,
    "magical_armor": 15,
    "visuals": {
      "color": {"r": 200, "g": 100, "b": 100, "a": 255},
      "radius_factor": 0.55,
      "stroke_width": 0
    }
  },
  {
    "id": "ENEMY_MAGIC_RESIST",
    "name": "Магический щит",
    "health": 240,
    "speed": 80.0,
    "physical_armor": -20,
    "magical_armor": 80,
    "visuals": {
      "color": {"r": 180, "g": 50, "b": 230, "a": 255},
      "radius_factor": 0.53,
      "stroke_width": 0
    }
  },
А вот towers
    {
    "id": "PA",
    "name": "PA (Сплит-физ.)",
    "type": "ATTACK",
    "crafting_level": 0,
    "level": 1,
    "combat": {
      "damage": 18,
      "fire_rate": 1.0,
      "range": 3,
      "shot_cost": 0.08,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "PHYSICAL",
        "params": {
          "split_count": 2
        }
      }
    },
    "visuals": {
      "color": {"r": 255, "g": 140, "b": 0, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "PE",
    "name": "PE (Сплит-маг.)",
    "type": "ATTACK",
    "crafting_level": 0,
    "level": 1,
    "combat": {
      "damage": 18,
      "fire_rate": 1.0,
      "range": 3,
      "shot_cost": 0.06,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "MAGICAL",
        "params": {
          "split_count": 2
        }
      }
    },
    "visuals": {
      "color": {"r": 221, "g": 160, "b": 221, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
    {
    "id": "PO",
    "name": "PO (Сплит-чист.)",
    "type": "ATTACK",
    "crafting_level": 0,
    "level": 1,
    "combat": {
      "damage": 15,
      "fire_rate": 1.0,
      "range": 3,
      "shot_cost": 0.1,
      "attack": {
        "type": "PROJECTILE",
        "damage_type": "PURE",
        "params": {
          "split_count": 2
        }
      }
    },
    "visuals": {
      "color": {"r": 224, "g": 255, "b": 255, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },
  {
    "id": "TOWER_SILVER",
    "name": "Сильвер",
    "type": "ATTACK",
    "crafting_level": 1,
    "level": 2,
    "combat": {
      "damage": 55,
      "fire_rate": 1.2,
      "range": 4,
      "shot_cost": 0.15,
      "attack": {
        "type": "LASER",
        "damage_type": "PHYSICAL"
      }
    },
    "visuals": {
      "color": {"r": 192, "g": 192, "b": 192, "a": 255},
      "radius_factor": 0.35,
      "stroke_width": 2.0
    }
  },
А вот recipes
  {
    "inputs": [
      { "id": "TA", "level": 1 },
      { "id": "PA", "level": 1 },
      { "id": "NI", "level": 1 }
    ],
    "output_id": "TOWER_SILVER"
  },
  {
    "inputs": [
      { "id": "PA", "level": 1 },
      { "id": "PE", "level": 1 },
      { "id": "PO", "level": 1 }
    ],
    "output_id": "TOWER_MALACHITE"
  },
  {
    "inputs": [
      { "id": "PE", "level": 1 },
      { "id": "DE", "level": 1 },
      { "id": "NU", "level": 1 }
    ],
    "output_id": "TOWER_VOLCANO"
  }
Ну и там же хранится таблица с вероятностями, вот так на данный момент выглядит 
  {
    "player_level": 1,
    "entries": [
      { "tower_id": "TA", "weight": 10 },
      { "tower_id": "TE", "weight": 10 },
      { "tower_id": "TO", "weight": 10 },
      { "tower_id": "PA", "weight": 10 },
      { "tower_id": "PE", "weight": 10 },
      { "tower_id": "PO", "weight": 10 },
      { "tower_id": "DE", "weight": 8 },
      { "tower_id": "NI", "weight": 8 },
      { "tower_id": "NU", "weight": 8 }
    ]
  }

С точки зрения рендера, у меня пока нет моделек и загрузчика, но планируется в ближайшем будущем. Однако я как бы при загрузке игры заранее создаю все матрицы для всех фигурок, это сильно оптимизирует отрисовку. Так же отрисовка идет в два этапа, в первом этапе все элементы тип бани, стены, руда, а во втором снаряды и юи, что бы они были поверх всего. 

Как ты понимаешь у меня бывает физический армор, магический армор, а так же физический урон, магический урон, чистый урон. Есть башня ауры со своим типом атаки, системным так сказать, он нужен что бы тратить ресурсы. Есть ещё вышка с замедлением, есть вышка с отравлением. 
Так же у меня есть разные типы атаки, сплит, соло, маяк который вращается, вулкан по области, сильвер что стреляет лазером и тд. 
Есть ауры что дают бонусы в радиусе. 

Теперь что вообще является сутью игры, мобы идут волнами, идут сначала по "чекпоинтами" (иногда я называю их "подарками"), от входа к выходу, более подробно вход -> 1 подарок -> 2 подарок -> 3 подарок -> 4 подарок -> 5 подарок -> 6 подарок  -> выход. Суть действий игрока сделать такой лабиринт из вышек, что бы максимум атакующей силы было сконцетрированно в центре, а лабиринт таким, что бы враги проходили через центр как можно чаще. Карта представляет собой правильный гекс (шестиугольник) с случайно измененными краями (есть на это условия определённые). Существуют жилы руды (скопление гексов руды). Существуют стены которые стоят заранее рядом с чекпоинта, ну и существуют чекпоинты. Так же гекс "входа" и гекс "выхода". 

Ещё у меня во время игры три состояния, состояние строителеьства, состояние выбора, состояние волны, во время строителсьтва можно ставить вышки, удалять вышки, выбирать(селект) что бы посмотреть, дальше в состояние выбора, там я выбираю две вышки которые потом будут автоматически сохранены дальше, остальные превратятся в камень. Позже идет фаза волны, то есть игры где идут враги, однако в эту фазу я могу слиять три вышки в 1 если это позволяет рецепты крафта, ну и так же мои вышки атакуют врагов, что бы их уничтожить. Да у меня есть книга рецептов и есть метка крафта, что делают процесс крафта более казуальным. 

В начале игры (создание карты) генерируется руда которая является основой системы энергии (логистики), то есть без руды нет атаки. Руда имеет некоторые правила генерации, что есть 3 жилы, центральная, средняя и крайняя, ну и правила распределения по этим жилам. Руду могут добывать башни типа добытчик/передатчик, я называю их башни типа Б. Также есть атакующие башни - это башни типа А (аура,замедление, отравление тоже входит в тип А). А ещё есть камни (стены), ну их называю камни или стены. Есть так же понятие сети, это просто запитанный граф, то есть набор вышек Б и А которые в сети, называю его С. Работа с рудой и системой энергии в основном в energy_network.go, ore_generation.go. А ещё, стены/камни я называю башнями типа Д. Башни А тоже делятся на под типы, есть обычная атака, есть сплит, есть замедление, есть яд, есть аура, есть маяк, ну и типы урона разные. Визуально руда отображается в двух эпостасях, первое это в hex_renderer как бы затемненые гекса, второе это в system/render там руда идет как пульсирующие кружки. 

Если говорить более локально, то есть подразделять башни типа А на под типы. Они разделены по типам атаки, не в плане физ магш и тп, а например сплит, соло цель и тп. То есть название вышки как бы состоит из 2 букв, например  TA, то есть обычная атака физическая, или PE сплит атака магическая, ну или DE аура скорости атаки и тд, сейчас есть TA TE TO PA PE PO DE NI NU, вот такое вот разделение. Но так же есть уровни у башен, 1 2 3 4 5 6, чем выше уровень тем больше у башни урона, размер. Так же есть уровни крафта, те вышки о которых я говорил выше имеют 0 уровень крафта, если из трех скрафтить что-то например сильвер, то он имеет первый уровень крафта, если из сильвера и ещё чего-то скрафтить новую вышку например сильвер найт, то это уже 2 уровень крафта. 

Дальше у меня есть две основные состовляющие, методы работы с гексами (hexmap logic и hexmap render), а так же это ECS. Методы работы с гексами вынесены в отдельный пакет и нужны для многих расчётов, а так же для пререндера карты. Методы работы с гексами так же содержет пререндер карты, он идет в hex_renderer, кроме этого ничего там не надо рендерить. ЕЩЁ РАЗ В her_renderer ПОЛНОЦЕННО И ОНО ПРЕРЕНДЕРИТ КАРТУ. То есть оно создает модельки каждого гекса, красит их, располагает, потом уже рендерит. 
А вот ECS, на её основе я уже много чего реализовал, компоненты лежат в  C:\go_project\go-tower-defense\internal\component, сейчас я пробегусь по всем и чуть подробнее расскажу о каждом:
aura - компонент Aura имеет радиус и скорость ускорения, так же есть компонент AuraEffect для просчета 
beacon - компонент для башни "Маяк" управляет ее уникальной механикой вращения и атаки, так же BeaconAttackSector - компонент для визуализации сектора атаки маяка
combat - атака у башен, там есть компоненты здоровья, ну и сам combat компонент для атаки (там скорострельность, кулдаун стрельбы, радиус атаки, стоимость руды для выстрела, ну тип атаки)
crafting - компонент Combinable указывает, что башня является частью действительного рецепта крафта, ещё тут есть CraftInfo содержит информацию о конкретном возможном крафте
enemy - компонент для врагов, там есть таймеры для проверки получения урона от энерго линий и от руд, ну а так же информация о арморе 
game_state - компонент состояния игры, я уже говорил о глобальной StateMachine, но есть и более локальная система состояние для переключения между фазами строительства, выбора и волны 
line - компонент для системы состояний это по сути кусочек который соединяет между собой два объекта системы энергии, есть связи формата Б-Б длиной до 3-х гексов, Б-А длиной 1 гекс ( соседи), А-А 1 гекс (соседи). Компонент LineRender содержит откуда куда, цвет, товера которые связанны этой линией
manual_selection - компонент для ручного выбора групп
movement - файл с компонентами движения, там есть компоненты позиции, скорости, пути 
ore - комонент для руды, она генерируется в методаха работы с гексами ( о них позже), а тут создается компонент для её визуала, а так же логики ей работы ( мощность, запас) то есть содержит мощность, запас, текущий запас, позиция, радиус, цвет, пульсация 
player - PlayerStateComponent хранит информацию, специфичную для игрока, такую как его текущий уровень и опыт, жизни его 
projectile - компонент для снарядов, тут много всего, в кого летит, скорость, урон, цвет, тип, замедляюющий ли снаряд, ядовитый и, нужно ли ему наведение
render - компонент для отрисовки
rotating_beam - компонент, но я хз он где-то используется или нет
selection - компонент для выбора соло
status_effect - компонент SlowEffect для замедления врагов и компонент PoisonEffect для яда и отравления 
text - где-то я рендерю текст, так что вот компонент для него 
tower - компонент для башни, ID из tower.json тип башни, радиус, гекс на котором она, активна ли башня, временная ( надо для выбора) и выбрана или нет
visual - там компонент DamageFlash это про эффект визуальный урона  
volcano - компонент для башни "Вулкан"
wave - компонент для волны врагов, тут есть номер, сколько врагов, таймер спавна, интервал междду спавном, путь для врагов 
Описал все компоненты, что имеются сейчас. Давай наверное теперь о system. Сначала есть общий файл что описывает все в ecs C:\go_project\go-tower-defense\internal\entity\ecs.go 
А ну да ещё есть конфиг, он вот тут C:\go_project\go-tower-defense\internal\config\config.go 
Ну теперь давай к системам C:\go_project\go-tower-defense\internal\system. 
Система aura - расчет аур, но не через Update, а просто функция для перерасчета аур
Система area_attack_system - управляет башнями, которые наносят урон по области
Система beacon_system - управляет башнями "Маяк".
Система combat - атаки башен, там я долго копался и сделал нормальную функцию поиска цели, что было не так просто, но зато теперь все хорошор работает. 
Система crafting - которая обрабатывает крафт 
Система environmental_damage - тут линии и руда наносит урон 
Система movement - работает движение
Система ore - система работы с рудой
Система player_system - отвечает за логику, связанную с игроком, например, за начисление опыта.
Система projectile - работа с снарядами, в целом я долго обдумывал как это реализовать и там тоже все хорошо
Система render - ну понятно, система отрисовки, сначала рисует пульсацию, затем сущности, после линии
Система state -я уже говорил обрпабатывает состояние игра/строительство 
Система status_effect.go - что бы как раз таки сделать эффект заморозки
Система utils - система которая выносит общие функции которые могут использовать другие системы, НАПРИМЕР ApplyDamage (ApplyDamage наносит урон сущности. Если здоровье падает до 0 или ниже, оно просто устанавливается в 0. Основная логика очистки мертвых сущностей должна находиться в другом месте (например, в конце кадра), чтобы избежать проблем с доступом к уже удаленным компонентам в том же кадре.)
Система visual_effect - ну тут про визуальные эффекты 
Система volcano_system - управляет башнями "Вулкан"
Ну и система волн wave 

Так же есть некоторое ui (C:\go_project\go-tower-defense\internal\ui) - состоит из 8 штук: кнопка паузы, кнопка ускорения, кнопка индикатора фазы (строительство/волна), кнопка фазы U (фаза перемещения линий у системы энергии), номер волны, индикатор опыта игрока, индикатор хп игрока, индикатор руд по жилам.  

Есть некоторые отладочные штуки. Первая из них позволяет постановить башни в обход обычного счётчика вышек. То есть при нажатие кнопки 1 я поставлю случайную башню типа А, при нажатие кнопки 2 я поставлю башню типа Б, а при нажатие кнопки 3 поставлю башню типа Д. Ещё есть отладка U, это будет и в итоговом проекте и есть сейчас, это режим который позволяет передвигать линии. Есть ещё зарезрвированная кнопка - 0, после нажатия на неё я ставлю конкретную башню которую тестирую, в настоящем это маяк. 

Стоит так же отметить логические системы которые у меня есть, это бонус урона бедной руды, деградация сети башнями типа А, метка крафта. И визуально башни отличаются, башни первого уровня они все кружки, башни второго уровня ( то есть получаемые 1 крафтом ) они квадратики, башни третьего уровня ( пока таких нет, но получаемые только из 2-х крафтов ) треугольники. 

Да есть много лоадеров, все они находятся в C:\go_project\go-tower-defense\internal\defs типо loader, enemies, towers, recipes, types, waves, loot_tables

Ну и теперь pkg там как бы основная работа с гексогональной сеткой, состоит из отрисовки и самой работы с сеткой, отрисовка в C:\go_project\go-tower-defense\pkg\render, а логические штуки в C:\go_project\go-tower-defense\pkg\hexmap

ПОСЛЕДНИЕ МОИ ДЕЙСТВИЯ В информация.txt 

Структура проекта:
├── assets
│   ├── data
│   │   ├── enemies.json
│   │   ├── loot_tables.json // таблица для вероятностей 
│   │   ├── recipes.json
│   │   └── towers.json
│   └── fonts
│       └── arial.ttf // шрифт который я использую для отрисовки
├── cmd
│   ├── game
│   │   └── main.go // основной файл, что управляет всей игрой, однако сейчас я развиваю game.go 
│   └── map_viewer_raylib
│       └── main.go
├── internal
│   ├── app
│   │   ├── energy_network.go // работа с энерго сетью
│   │   ├── game.go // вся логика и вся суть игры тута
│   │   ├── ore_generation.go // генерация руды
│   │   └── tower_management.go // работа с вышками 
│   ├── component
│   │   ├── aura.go // компонент Aura и AuraEffect
│   │   ├── beacon.go // для работы маяка 
│   │   ├── combat.go //компоненты Health и Combat 
│   │   ├── crafting.go
│   │   ├── enemy.go //компонент Enemy 
│   │   ├── game_state.go //компонент GameState + const BuildState, WaveState, TowerSelectionState
│   │   ├── line.go //компонент LineRender для линий 
│   │   ├── manual_selection.go
│   │   ├── movement.go //тут есть компоненты Position, Velocity, Path
│   │   ├── ore.go //компонент Ore 
│   │   ├── player.go // это как бы сущность игрок которая нужна для лвла и рандома
│   │   ├── projectile.go //компонент Projectile 
│   │   ├── render.go //компонент Renderable
│   │   ├── rotating_beam.go 
│   │   ├── selection.go
│   │   ├── status_effect.go //компонент SlowEffect и компонент PoisonEffect
│   │   ├── text.go //компонент Text 
│   │   ├── tower.go //компонент Tower
│   │   ├── visual.go //компонент DamageFlash для эффектов (эффект получения урона)
│   │   ├── volcano.go // для работы вышки с названием вулкан 
│   │   └── wave.go //компонент Wave 
│   ├── config
│   │   └── config.go // все конфииги тут 
│   ├── defs
│   │   ├── enemies.go // статические данные для определения типа противника 
│   │   ├── loader.go // загрузчик из json в ecs 
│   │   ├── loot_tables.go
│   │   ├── recipes.go
│   │   ├── towers.go // статические данные для определения типа вышки
│   │   ├── types.go // статические данные для определения типа атак
│   │   └── waves.go
│   ├── entity
│   │   └── ecs.go // 
│   ├── event
│   │   ├── event.go //штука событий, то есть мы имеем события например удаление сущности 
│   │   └── types.go //и вот мы в этой логике event как бы обрабатываем все 
│   ├── interfaces
│   │   ├── game.go // тут есть ClearEnemies ClearProjectiles StartWave 
│   │   └── game_context.go  // вынос общих штук, что бы не было цикличного импорта 
│   ├── state
│   │   ├── game_state.go  // основная стадия игры, тут много логики работы с ui, общая для фаз и тп
│   │   ├── menu_state.go  // меню
│   │   ├── pause_state.go // пауза
│   │   └── state.go // глобальная StateMachine 
│   ├── system
│   │   ├── area_attack_system.go
│   │   ├── aura.go
│   │   ├── beacon_system.go // для работы маяка 
│   │   ├── combat.go
│   │   ├── crafting.go
│   │   ├── environmental_damage.go
│   │   ├── movement.go
│   │   ├── ore.go
│   │   ├── player_system.go
│   │   ├── projectile.go
│   │   ├── render.go
│   │   ├── state.go
│   │   ├── status_effect.go
│   │   ├── utils.go
│   │   ├── visual_effect.go
│   │   ├── volcano_system.go // для работы вулкана 
│   │   └── wave.go
│   ├── types
│   │   └── types.go// вроде геттер для EntityID
│   ├── ui
│   │   ├── indicator.go
│   │   ├── info_panel.go // ui шка которая нужна что бы показывать состояние сущностей
│   │   ├── pause_button.go // ui шка что бы ставить паузу (альтернатива F9) 
│   │   ├── player_health_indicator.go
│   │   ├── player_level_indicator.go // ui шка для демонстрации лвла игрока 
│   │   ├── recipe_book.go
│   │   ├── speed_button.go // ui шка для контроля скорости игры
│   │   ├── u_indicator.go
│   │   └── wave_indicator.go
│   └── utils
│       ├── coords.go
│       ├── prng.go // тут рандом считается
│       └── union_find.go
├── pkg
│   ├── hexmap
│   │   ├── hex.go
│   │   ├── map.go
│   │   ├── map_3d.go
│   │   ├── ore_generation_3d.go
│   │   ├── pathfinding.go
│   │   └── utils.go
│   ├── render
│   │   ├── color.go
│   │   └── hex_renderer.go
│   └── utils
│       ├── math.go
│       └── union_find.go
├── .env
├── .gitignore
├── analyze.txt
├── analyze_project.py
├── game.exe
├── GEMINI.md
├── go.mod
├── go.sum
├── main.exe
├── profile
├── reset_env.ps1
├── stp_td что сделанно.txt
├── stp_td что сделать.txt
├── генерация руды.txt
├── диалог.txt
├── дневник.txt
├── игра 3.png
├── игра 4.png
├── игра 5.png
├── игра.png
├── игрга 2.png
├── история.txt
└── ошибки.txt





В информация.txt лежат последние действия

При рефакторинге придерживаюсь следующих принципов:
1. Устранение хардкода: Все магические числа/строки заменяются на именованные константы в коде или выносятся в internal/config.
2. Централизация конфигурации: Параметры, влияющие на баланс/логику (скорости, лимиты, цвета, пути ассетов) хранятся ТОЛЬКО в config.go.
3. Минимальная валидация: Проверка входных данных выполняется только в точках ввода (UI, загрузка файлов, публичные методы пакетов).
4. Абстракция утилит: Повторяющаяся логика (математика, преобразования, алгоритмы) выносится в utils, для всего что в system (все системы) есть свой utils, для pkg (гексоганальная сетка) есть свой utils 
5. Соответствие абстракций: Уровень детализации методов строго соответствует контексту 


