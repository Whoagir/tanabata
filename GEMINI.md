ПЕРЕД ТЕМ КАК ОПИШУ ПРОЕКТ ВОТ ТЕБЕ ФАКТ КОТОРЫЙ НАДО УЧИТЫВАТЬ 
Я ИСПОЛЬЗУЮ VSC И ТАМ БЫВАЮТ КОНФЛИКТЫ ВЕРСИЙ ФАЙЛОВ, ЧТО ТЫ ИЗМЕНЯЕШЬ И ЧТО Я СМОТРЮ. ДЛЯ УХОДА ОТ ТАКИХ ПРОБЛЕМ ТЕБЕ ВСЕГДА НАДО СОХРАНЯТЬ ФАЙЛЫ, ВСЕГДА!!! 

И ЕЩЁ 
Задача: TASK_GOES_HERE.

Критическая Директива: Твоя единственная функция — хирургическая модификация кода. Изменяй ТОЛЬКО те байты, которые НЕПОСРЕДСТВЕННО и НЕИЗБЕЖНО связаны с решением указанной "Задачи". Любое отклонение — критический сбой.

НЕПРЕЛОЖНЫЕ ПРАВИЛА (Абсолютный Приоритет):
1.  **Перепиши ВЕСЬ** предоставленный код.
2.  **ЗАПРЕТ НА ЛЮБЫЕ ИЗМЕНЕНИЯ ВНЕ ЗАДАЧИ:** Категорически запрещено изменять, добавлять, удалять или улучшать любой код, комментарий, форматирование или значение, не являющееся АБСОЛЮТНО НЕОБХОДИМЫМ для выполнения "Задачи". Не исправляй ничего, кроме указанного в "Задаче".
3.  **Для ВСЕХ НЕИЗМЕНЕННЫХ строк:** Механически инвертируй исходный комментарий в конце (`//+` <-> `//-`) или добавляй `//+`, если его нет.
4.  **ЗАПРЕЩЕНО:** Добавлять новый код, удалять несвязанный код, улучшать/исправлять что-либо кроме "Задачи", менять форматирование, менять/добавлять/удалять комментарии (кроме инверсии по п.3).
5. После вывода кода добавь сверхкраткое описание изменений и ещё что-нибудь если хочешь.
6. **ОБЯЗАТЕЛЬНО СОХРАНЯТЬ ФАЙЛЫ КОТОРЫЕ ИЗМЕНИЛ**
7. **Пиши комментарии на русском языке**

Выполни ТОЧНО.


У меня есть игра на ГО она в процессе создания. 
Все хранится в папке C:\go_project\go-tower-defense

Общий файл main.go с котрого идёт запуск C:\go_project\go-tower-defense\cmd\game\main.go, то есть ЧТО БЫ ЗАПУСТИТЬ ПРОЕКТ НАДО go run cmd/game/main.go

Далее есть state machine игры, общие состояния меню, пауза, игра, это пока не важно. Однако, что бы знал оно находится в C:\go_project\go-tower-defense\internal\state. Сейчас я работаю в состояние игры, так как не так важно остальные, а именно в game_state.go 
 
Основная часть игры находится в C:\go_project\go-tower-defense\internal\app, более конкрентно 
app
├── energy_network.go //концепция энергии
├── game.go //основная логика
├── ore_generation.go //генерация руды
└── tower_management.go  //работа с вышками 

Вот описание игры, это тавер дефенс на гексоганальной сетке в стиле ГЕМ ТД (кастомной карты из доты 2 и варкрафта), я внес несколько новых механик, и теперь у меня ТРИ основные механики - постройка лабиринта, рандом, логистика. Постройка лабиринта уже реализована, логистика тоже в большей части. Сейчас я доделываю мелочи и перехожу к разнообразию вышек, что бы был рандом. Кстати, про разнообразие, сейчас я добавляю разные вышки и разных врагов, логически они лежат так assets/data, там есть enemies.json и в towers.json. А ну так же у меня есть internal/defs/loader.go н как бы парсит этот json для использования в игре. А ну в целом в internal/defs содержатся штуки для работы с ним.

Теперь что вообще является сутью игры, мобы идут волнами, идут сначала по "чекпоинтами" (иногда я называю их "подарками"), от входа к выходу, более подробно вход -> 1 подарок -> 2 подарок -> 3 подарок -> 4 подарок -> 5 подарок -> 6 подарок  -> выход. Суть действий игрока сделать такой лабиринт, что бы максимум атакующей силы было сконцетрированно в центре, а лабиринт таким, что бы враги проходили через центр как можно чаще. Карта представляет собой правильный гекс (шестиугольник) с случайно измененными краями (есть на это условия определённые). Существуют жилы руды (скопление гексов руды). 

В начале игры (создание карты) генерируется руда которая является основой системы энергии (логистики), то есть без руды нет атаки. Руду могут добывать башни типа добытчик/передатчик, я называю их башни типа Б. Также есть атакующие башни - это башни типа А. А ещё есть камни (стены), ну их называю камни или стены. Есть так же понятие сети, это просто запитанный граф, называю его С. Работа с рудой и системой энергии в основном в energy_network.go, ore_generation.go

Дальше у меня есть две основные состовляющие, методы работы с гексами (hexmap logic и hexmap render), а так же это ECS. Методы работы с гексами так же содержет пререндер карты, он идет в hex_renderer, кроме этого ничего там не надо рендерить. А вот ecs, на её основе я уже много чего реализовал, компоненты лежат в  C:\go_project\go-tower-defense\internal\component, сейчас я пробегусь по всем и чуть подробнее расскажу о каждом:
combat - атака у башен, там есть компоненты здоровья, ну и сам combat компонент для атаки
enemy - компонент для врагов, пока там ничего нет, но будет далее
game_state - компонент состояния игры, я уже говорил о глобальной StateMachine, но есть и более локальная система состояние для переключения между фазами строительства и волны 
line - компонент для системы состояний это по сути кусочек который соединяет между собой два объекта системы энергии, есть связи формата Б-Б длиной до 3-х гексов, Б-А длиной 1 гекс ( соседи), А-А 1 гекс (соседи)
movement - файл с компонентами движения, там есть компоненты позиции, скорости, пути 
ore - комонент для руды, она генерируется в методаха работы с гексами ( о них позже), а тут создается компонент для её визуала, а так же логики ей работы ( мощность, запас)
projectile - компонент для снарядов
render - компонент для отрисовки
text - где-то я рендерю текст, так что вот компонент для него 
tower - компонент для башни, ну тут из интересного это активна ли башня, он нужен для системы энергии, если башня в системе то она активна, иначе пассивна 
visual - там компонент DamageFlash это про эффект визуальный урона  
wave - компонент для волны врагов 
Описал все компоненты, что имеются сейчас. Давай наверное теперь о system. Сначала есть общий файл что описывает все в ecs C:\go_project\go-tower-defense\internal\entity\ecs.go 
А ну да ещё есть конфиг, он вот тут C:\go_project\go-tower-defense\internal\config\config.go 
Ну теперь давай к системам C:\go_project\go-tower-defense\internal\system. 
Система combat - атаки башен, там я долго копался и сделал нормальную функцию поиска цели, что было не так просто, но зато теперь все хорошор работает. 
Система movement - работает движение
Система projectile - работа с снарядами, в целом я долго обдумывал как это реализовать и там тоже все хорошо. 
Система render - ну понятно, система отрисовки, сначала рисует пульсацию, затем сущности, после линии
Система state -я уже говорил обрпабатывает состояние игра/строительство 
Система ore - система работы с рудой
Система utils - система которая выносит общие функции которые могут использовать другие системы, НАПРИМЕР ApplyDamage (ApplyDamage наносит урон сущности. Если здоровье падает до 0 или ниже, оно просто устанавливается в 0. Основная логика очистки мертвых сущностей должна находиться в другом месте (например, в конце кадра), чтобы избежать проблем с доступом к уже удаленным компонентам в том же кадре.)
Система visual_effect - ну тут про визуальные эффекты 
Ну и система волн wave 

Давай опишу, как выглядит enemies в json пример 
  {
    "id": "DEFAULT_ENEMY",
    "name": "Стандартный враг",
    "health": 100,
    "speed": 80.0,
    "armor_type": "PHYSICAL",
    "armor_value": 5,
    "visuals": {
      "color": {"r": 0, "g": 0, "b": 0, "a": 255},
      "radius_factor": 0.53,
      "stroke_width": 0
    }
  },
А вот towers
  {
    "id": "TOWER_RED",
    "name": "Красная башня",
    "type": "ATTACK",
    "combat": {
      "damage": 10,
      "fire_rate": 2.0,
      "range": 3,
      "shot_cost": 0.12,
      "attack_type": "PHYSICAL"
    },
    "visuals": {
      "color": {"r": 255, "g": 50, "b": 50, "a": 255},
      "radius_factor": 0.3,
      "stroke_width": 2.0
    }
  },

Так же есть некоторое ui (C:\go_project\go-tower-defense\internal\ui) - состоит из 4 штук, кнопка паузы, кнопка ускорения, и кнопка индикатора фазы (строительство/волна), кнопка фазы U (фаза перемещения линий у системы энергии)

Ну и теперь pkg там как бы основная работа с гексогональной сеткой, состоит из отрисовки и самой работы с сеткой, отрисовка в C:\go_project\go-tower-defense\pkg\render, а логические штуки в C:\go_project\go-tower-defense\pkg\hexmap

Структура проекта:
├── assets
│   ├── data
│   │   ├── enemies.json
│   │   └── towers.json
│   └── fonts
│       └── arial.ttf // шрифт который я использую для отрисовки
├── cmd
│   └── game
│       └── main.go // основной файл, что управляет всей игрой, однако сейчас я развиваю game.go 
├── internal
│   ├── app
│   │   ├── energy_network.go // работа с энерго сетью
│   │   ├── game.go // вся логика и вся суть игры тута
│   │   ├── ore_generation.go // генерация руды
│   │   └── tower_management.go // работа с вышками 
│   ├── component
│   │   ├── combat.go //компоненты Health и Combat 
│   │   ├── enemy.go //компонент Enemy 
│   │   ├── game_state.go //компонент для system state (фаза строительства и фаза "игры") 
│   │   ├── line.go //компонент LineRender для линий 
│   │   ├── movement.go //тут есть компоненты Position, Velocity, Path
│   │   ├── ore.go //компонент Ore 
│   │   ├── projectile.go //компонент Projectile 
│   │   ├── render.go //компонент Renderable
│   │   ├── text.go //компонент Text 
│   │   ├── tower.go //компонент Tower
│   │   ├── visual.go //компонент DamageFlash для эффектов (эффект получения урона)
│   │   └── wave.go //компонент Wave 
│   ├── config
│   │   └── config.go //
│   ├── defs
│   │   ├── enemies.go
│   │   ├── loader.go
│   │   ├── towers.go
│   │   └── types.go
│   ├── entity
│   │   └── ecs.go //
│   ├── event
│   │   ├── event.go //штука событий, то есть мы имеем события например удаление сущности 
│   │   └── types.go //и вот мы в этой логике event как бы обрабатываем все 
│   ├── interfaces
│   │   └── game_context.go  // вынос общих штук, что бы не было цикличного импорта 
│   ├── state
│   │   ├── game_state.go  // основная стадия игры, тут много логики работы с ui, общая для фаз и тп
│   │   ├── menu_state.go  // меню
│   │   ├── pause_state.go // пауза
│   │   └── state.go // глобальная StateMachine 
│   ├── system
│   │   ├── combat.go
│   │   ├── environmental_damage.go
│   │   ├── movement.go
│   │   ├── ore.go
│   │   ├── projectile.go
│   │   ├── render.go
│   │   ├── state.go
│   │   ├── utils.go
│   │   ├── visual_effect.go
│   │   └── wave.go
│   ├── types
│   │   └── types.go// вроде геттер для EntityID
│   └── ui
│       ├── indicator.go // индикатор состояния игры, строительство или фаза игры
│       ├── pause_button.go// кнопка паузы 
│       └── speed_button.go// кнопка ускорения 
├── pkg
│   ├── hexmap
│   │   ├── hex.go
│   │   ├── map.go
│   │   ├── pathfinding.go
│   │   └── utils.go
│   ├── render
│   │   ├── color.go
│   │   └── hex_renderer.go
│   └── utils
│       ├── math.go
│       └── union_find.go
├── .env
├── .gitignore
├── analyze.txt
├── analyze_project.py
├── commit_message.txt
├── game.exe
├── GEMINI.md
├── go.mod
├── go.sum
├── profile
├── reset_env.ps1
├── stp_td что сделанно.txt
├── stp_td что сделать.txt
├── енерация руды.txt
└── информация.txt






Так же если ты хочешь ознакомиться с тем, что сделано это лежит рядом с тобой C:\go_project\gemini\stp_td что сделанно.txt 
В информация.txt лежат последние действия

При рефакторинге придерживаюсь следующих принципов:
1. Устранение хардкода: Все магические числа/строки заменяются на именованные константы в коде или выносятся в internal/config.
2. Централизация конфигурации: Параметры, влияющие на баланс/логику (скорости, лимиты, цвета, пути ассетов) хранятся ТОЛЬКО в config.go.
3. Минимальная валидация: Проверка входных данных выполняется только в точках ввода (UI, загрузка файлов, публичные методы пакетов).
4. Абстракция утилит: Повторяющаяся логика (математика, преобразования, алгоритмы) выносится в utils, для всего что в system (все системы) есть свой utils, для pkg (гексоганальная сетка) есть свой utils 
5. Соответствие абстракций: Уровень детализации методов строго соответствует контексту 


