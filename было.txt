// internal/system/render.go
package system

import (
	"go-tower-defense/internal/component"
	"go-tower-defense/internal/config"
	"go-tower-defense/internal/defs"
	"go-tower-defense/internal/entity"
	"go-tower-defense/internal/types"
	"go-tower-defense/pkg/hexmap"
	"image/color"
	"math"

	rl "github.com/gen2brain/raylib-go/raylib"
)

// RenderSystemRL - новая система рендеринга для Raylib
type RenderSystemRL struct {
	ecs    *entity.ECS
	font   rl.Font
	camera *rl.Camera3D
}

// NewRenderSystemRL создает новую систему рендеринга
func NewRenderSystemRL(ecs *entity.ECS, font rl.Font) *RenderSystemRL {
	return &RenderSystemRL{
		ecs:  ecs,
		font: font,
	}
}

// SetCamera устанавливает камеру для системы рендеринга.
func (s *RenderSystemRL) SetCamera(camera *rl.Camera3D) {
	s.camera = camera
}

// Draw рисует все динамические сущности
func (s *RenderSystemRL) Draw(gameTime float64, isDragging bool, sourceTowerID, hiddenLineID types.EntityID, gameState component.GamePhase, cancelDrag func()) {
	if s.camera == nil {
		return
	}
	s.drawPulsingOres(gameTime)
	s.drawEntities()
	s.drawLines(hiddenLineID)
	s.drawLasers()
	s.drawRotatingBeams()
	s.drawDraggingLine(isDragging, sourceTowerID, cancelDrag)
	s.drawText()
	s.drawCombinationIndicators()
}

func (s *RenderSystemRL) Update(deltaTime float64) {
	for id, laser := range s.ecs.Lasers {
		laser.Timer += deltaTime
		if laser.Timer >= laser.Duration {
			delete(s.ecs.Lasers, id)
		}
	}
}

// hexToWorld преобразует гекс в мировые 3D-координаты
func (s *RenderSystemRL) hexToWorld(h hexmap.Hex) rl.Vector3 {
	x, y := h.ToPixel(float64(config.HexSize))
	return rl.NewVector3(float32(x*config.CoordScale), 0, float32(y*config.CoordScale))
}

// pixelToWorld преобразует пиксельные координаты в мировые 3D-координаты
func (s *RenderSystemRL) pixelToWorld(p component.Position) rl.Vector3 {
	return rl.NewVector3(float32(p.X*config.CoordScale), 0, float32(p.Y*config.CoordScale))
}

func (s *RenderSystemRL) drawLasers() {
	for _, laser := range s.ecs.Lasers {
		alpha := 1.0 - (laser.Timer / laser.Duration)
		if alpha < 0 {
			alpha = 0
		}
		r, g, b, _ := laser.Color.RGBA()
		lineColor := rl.NewColor(uint8(r>>8), uint8(g>>8), uint8(b>>8), uint8(alpha*255))

		startPos := s.pixelToWorld(component.Position{X: laser.FromX, Y: laser.FromY})
		endPos := s.pixelToWorld(component.Position{X: laser.ToX, Y: laser.ToY})

		rl.DrawLine3D(startPos, endPos, lineColor)
	}
}

func (s *RenderSystemRL) drawPulsingOres(gameTime float64) {
	for id, ore := range s.ecs.Ores {
		if pos, hasPos := s.ecs.Positions[id]; hasPos {
			worldPos := s.pixelToWorld(*pos)

			scaledRadius := float32(ore.Radius * config.CoordScale)
			pulseRadius := scaledRadius * float32(1+0.1*math.Sin(gameTime*ore.PulseRate*math.Pi/5))
			pulseAlpha := uint8(128 + 64*math.Sin(gameTime*ore.PulseRate*math.Pi/5))
			oreColor := config.OreColorRL
			oreColor.A = pulseAlpha

			scaledHeight := float32(0.1 * config.CoordScale)
			worldPos.Y = scaledHeight/2 + 2.0

			rl.DrawCylinder(worldPos, pulseRadius, pulseRadius, scaledHeight, 20, oreColor)
		}
	}
}

func (s *RenderSystemRL) drawEntities() {
	for id, renderable := range s.ecs.Renderables {
		if _, isLine := s.ecs.LineRenders[id]; isLine {
			continue
		}
		if _, isTower := s.ecs.Towers[id]; isTower {
			s.drawEntity(id, renderable, nil)
			continue
		}
		if pos, ok := s.ecs.Positions[id]; ok {
			s.drawEntity(id, renderable, pos)
		}
	}
}

func (s *RenderSystemRL) drawEntity(id types.EntityID, renderable *component.Renderable, pos *component.Position) {
	finalColor := colorToRL(renderable.Color)

	if _, ok := s.ecs.DamageFlashes[id]; ok {
		finalColor = config.EnemyDamageColorRL
	} else if _, ok := s.ecs.PoisonEffects[id]; ok {
		finalColor = config.ProjectileColorPoisonRL
	} else if _, ok := s.ecs.SlowEffects[id]; ok {
		finalColor = config.ProjectileColorSlowRL
	}

	scaledRadius := float32(renderable.Radius * config.CoordScale)

	var worldPos rl.Vector3
	if tower, isTower := s.ecs.Towers[id]; isTower {
		worldPos = s.hexToWorld(tower.Hex)
	} else if pos != nil {
		worldPos = s.pixelToWorld(*pos)
	} else {
		return
	}

	if _, isEnemy := s.ecs.Enemies[id]; isEnemy {
		worldPos.Y = scaledRadius
		rl.DrawSphere(worldPos, scaledRadius, finalColor)
		if renderable.HasStroke {
			rl.DrawSphereWires(worldPos, scaledRadius, 8, 8, rl.White)
		}
	} else if tower, isTower := s.ecs.Towers[id]; isTower {
		towerDef, ok := defs.TowerDefs[tower.DefID]
		if !ok {
			return
		}

		height := s.GetTowerRenderHeight(tower, renderable)
		startPos := rl.NewVector3(worldPos.X, 0, worldPos.Z)
		endPos := rl.NewVector3(worldPos.X, height, worldPos.Z)

		switch {
		case towerDef.Type == defs.TowerTypeWall:
			radius := scaledRadius * 1.8
			// ИСПРАВЛЕНО: Используем DrawCylinderEx для точного позиционирования
			rl.DrawCylinderEx(startPos, endPos, radius, radius, 6, finalColor)
			if renderable.HasStroke {
				rl.DrawCylinderWiresEx(startPos, endPos, radius, radius, 6, rl.White)
			}

		case towerDef.Type == defs.TowerTypeMiner:
			radius := scaledRadius * 1.2
			rl.DrawCylinderEx(startPos, endPos, radius, 0, 16, finalColor)
			if renderable.HasStroke {
				rl.DrawCylinderWiresEx(startPos, endPos, radius, 0, 16, rl.White)
			}

		case tower.CraftingLevel >= 1:
			// Для куба оставляем старый метод, но корректируем Y
			worldPos.Y = height / 2
			size := scaledRadius * 2
			rl.DrawCube(worldPos, size, height, size, finalColor)
			if renderable.HasStroke {
				rl.DrawCubeWires(worldPos, size, height, size, rl.White)
			}

		default:
			radius := scaledRadius * 1.2
			// ИСПРАВЛЕНО: Используем DrawCylinderEx для точного позиционирования
			rl.DrawCylinderEx(startPos, endPos, radius, radius, 24, finalColor)
			if renderable.HasStroke {
				rl.DrawCylinderWiresEx(startPos, endPos, radius, radius, 24, rl.White)
			}
		}
	} else {
		worldPos.Y = scaledRadius
		rl.DrawSphere(worldPos, scaledRadius, finalColor)
	}
}

func (s *RenderSystemRL) drawCombinationIndicators() {
	for id := range s.ecs.Combinables {
		if tower, ok := s.ecs.Towers[id]; ok {
			if renderable, ok := s.ecs.Renderables[id]; ok {
				worldPos := s.hexToWorld(tower.Hex)
				height := s.GetTowerRenderHeight(tower, renderable)

				scaledTowerRadius := float32(renderable.Radius * config.CoordScale)
				scaledIndicatorRadius := scaledTowerRadius / 2
				indicatorOffset := float32(2.0 * config.CoordScale)
				worldPos.Y = height + indicatorOffset + scaledIndicatorRadius

				rl.DrawSphere(worldPos, scaledIndicatorRadius, rl.Black)
				rl.DrawSphereWires(worldPos, scaledIndicatorRadius+float32(0.2*config.CoordScale), 6, 6, rl.White)
			}
		}
	}
}

func (s *RenderSystemRL) drawLines(hiddenLineID types.EntityID) {
	for id, line := range s.ecs.LineRenders {
		if id == hiddenLineID {
			continue
		}
		tower1, ok1 := s.ecs.Towers[line.Tower1ID]
		render1, ok1r := s.ecs.Renderables[line.Tower1ID]
		tower2, ok2 := s.ecs.Towers[line.Tower2ID]
		render2, ok2r := s.ecs.Renderables[line.Tower2ID]

		if ok1 && ok1r && ok2 && ok2r {
			startPos := s.hexToWorld(tower1.Hex)
			endPos := s.hexToWorld(tower2.Hex)

			height1 := s.GetTowerRenderHeight(tower1, render1)
			height2 := s.GetTowerRenderHeight(tower2, render2)

			startPos.Y = height1
			endPos.Y = height2

			rl.DrawCapsule(startPos, endPos, 0.6, 8, 8, rl.Yellow)
		}
	}
}

func (s *RenderSystemRL) GetTowerRenderHeight(tower *component.Tower, renderable *component.Renderable) float32 {
	scaledRadius := float32(renderable.Radius * config.CoordScale)
	towerDef, ok := defs.TowerDefs[tower.DefID]
	if !ok {
		return scaledRadius * 4
	}

	switch {
	case towerDef.Type == defs.TowerTypeWall:
		return scaledRadius * 1.5
	case towerDef.Type == defs.TowerTypeMiner:
		return scaledRadius * 9.0
	case tower.CraftingLevel >= 1:
		return scaledRadius * 4.0
	default:
		return scaledRadius * 7.0
	}
}

func (s *RenderSystemRL) drawDraggingLine(isDragging bool, sourceTowerID types.EntityID, cancelDrag func()) {
	if !isDragging || sourceTowerID == 0 {
		return
	}
	sourceTower, ok := s.ecs.Towers[sourceTowerID]
	if !ok {
		return
	}

	ray := rl.GetMouseRay(rl.GetMousePosition(), *s.camera)
	t := -ray.Position.Y / ray.Direction.Y
	hitPoint := rl.Vector3Add(ray.Position, rl.Vector3Scale(ray.Direction, t))

	startPos := s.hexToWorld(sourceTower.Hex)

	maxDragDist := float32(300 * config.CoordScale)
	if rl.Vector3Distance(startPos, hitPoint) > maxDragDist {
		cancelDrag()
		return
	}

	rl.DrawLine3D(startPos, hitPoint, rl.Yellow)
}

func (s *RenderSystemRL) drawText() {
	for _, txt := range s.ecs.Texts {
		worldPos := s.pixelToWorld(txt.Position)
		screenPos := rl.GetWorldToScreen(worldPos, *s.camera)
		rl.DrawTextEx(s.font, txt.Value, screenPos, float32(s.font.BaseSize), 1.0, colorToRL(txt.Color))
	}
}

func (s *RenderSystemRL) drawRotatingBeams() {
	if s.ecs.GameState.Phase != component.WaveState {
		return
	}
	for id, beam := range s.ecs.RotatingBeams {
		if tower, ok := s.ecs.Towers[id]; ok {
			beamColor := rl.NewColor(255, 255, 102, 80)
			worldPos := s.hexToWorld(tower.Hex)

			scaledRange := float32(float64(beam.Range*config.HexSize) * config.CoordScale)

			angle1 := beam.CurrentAngle - beam.ArcAngle/2
			angle2 := beam.CurrentAngle + beam.ArcAngle/2

			endX1 := worldPos.X + scaledRange*float32(math.Cos(angle1))
			endZ1 := worldPos.Z + scaledRange*float32(math.Sin(angle1))
			endX2 := worldPos.X + scaledRange*float32(math.Cos(angle2))
			endZ2 := worldPos.Z + scaledRange*float32(math.Sin(angle2))

			endPos1 := rl.NewVector3(endX1, worldPos.Y, endZ1)
			endPos2 := rl.NewVector3(endX2, worldPos.Y, endZ2)

			rl.DrawLine3D(worldPos, endPos1, beamColor)
			rl.DrawLine3D(worldPos, endPos2, beamColor)
		}
	}
}

// colorToRL преобразует стандартный color.Color в rl.Color
func colorToRL(c color.Color) rl.Color {
	r, g, b, a := c.RGBA()
	return rl.NewColor(uint8(r>>8), uint8(g>>8), uint8(b>>8), uint8(a>>8))
}