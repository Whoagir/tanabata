Игра запустилась успешно. Надеюсь, теперь индикатор "U" находится в правильном месте.

  Поскольку все исправления для Этапа 1 завершены, я готов вернуться к Этапу 2: созданию индикатора запасов
  руды.

  Я продолжу с того места, где мы остановились: анализ файла pkg/hexmap/ore_generation_3d.go, который я уже
  прочитал.

  Анализ `ore_generation_3d.go`:

   * Три центра: Код явно находит три центра для рудных жил:
       1. Центр 1: Близко к центру карты (distance < 3).
       2. Центр 2: На среднем расстоянии (distance >= 4 && distance <= 9).
       3. Центр 3: Далеко от центра (distance >= 10).
   * Три жилы (`veinAreas`): Вокруг этих центров создаются три области (veinAreas), которые и представляют
     наши секторы.
   * Распределение руды: Общая мощность руды (totalMapPower) делится на три части (totalPowers) для каждой
     жилы.

  Вывод: Логика разделения руды на три сектора (жилы) уже существует. Я могу использовать veinAreas и
  centers из логики генерации, чтобы определить, к какому сектору принадлежит каждый гекс с рудой.

  Следующий шаг:

  Теперь я создам новый UI-компонент internal/ui/ore_sector_indicator.go. Он будет содержать структуру и
  функцию Draw для отрисовки трех полос прогресса.

  Вы согласны?

╭─────────────────────────────────────────────────────────────────────────────────────────────────────╮
│  > Да идея хорошая, это не полосы прогресса, а полосы которые показывают насколько источилась руда  │
╰─────────────────────────────────────────────────────────────────────────────────────────────────────╯

✦ Понял. Это не "прогресс", а "деградация". Полосы должны показывать, сколько руды осталось в каждой из трех
  жил. Чем меньше руды, тем короче полоса.

  План действий:

   1. Создать файл: Я создам новый файл internal/ui/ore_sector_indicator.go.
   2. Определить структуру: В файле будет структура OreSectorIndicatorRL с позицией и размерами.
   3. Реализовать `Draw`: Функция Draw будет принимать три значения (от 0.0 до 1.0), представляющие процент
      оставшейся руды в центральной, средней и дальней жиле. Она будет рисовать три вертикальные полосы. Каждая
       полоса будет иметь фон и "заполнение", высота которого будет соответствовать проценту оставшейся руды.

  Приступаю к созданию файла internal/ui/ore_sector_indicator.go.
 ╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
 │ ✔  WriteFile Writing to internal\ui\ore_sector_indicator.go                                       │
 │                                                                                                   │
 │     1 // internal/ui/ore_sector_indicator.go                                                      │
 │     2 package ui                                                                                  │
 │     3                                                                                             │
 │     4 import (                                                                                    │
 │     5 "go-tower-defense/internal/config"                                                          │
 │     6        image/color"                                                                               │
 │     7                                                                                             │
 │     8        rl"github.com/gen2brain/raylib-go/raylib"                                                  │
 │     9 )                                                                                           │
 │    10                                                                                             │
 │    11 // OreSectorIndicatorRL отображает состояние рудных жил в трех секторах.                    │
 │    12 type OreSectorIndicatorRL struct {                                                          │
 │    13 X, Y         float32                                                                        │
 │    14 Width, Height float32                                                                       │
 │    15        BarWidth    float32                                                                        │
 │    16        Spacing     float32                                                                        │
 │    17 }                                                                                           │
 │    18                                                                                             │
 │    19 // NewOreSectorIndicatorRL создает новый индикатор состояния рудных жил.                    │
 │    20 func NewOreSectorIndicatorRL(x, y, width, height float32) *OreSectorIndicatorRL {           │
 │    21 return &OreSectorIndicatorRL{                                                               │
 │    22 X:        x,                                                                                │
 │    23 Y:        y,                                                                                │
 │    24                Width:    width,                                                                          │
 │    25                Height:   height,                                                                         │
 │    26                BarWidth: (width 2*10) / 3, // 3 бара с отступами по 10                                   │
 │    27 Spacing:  10,                                                                               │
 │    28        }                                                                                          │
 │    29 }                                                                                           │
 │    30                                                                                             │
 │    31 // Draw отрисовывает индикатор.                                                             │
 │    32 // centralPct, midPct, farPct - процент оставшейся руды (от 0.0 до 1.0).                    │
 │    33 func (i *OreSectorIndicatorRL) Draw(centralPct, midPct, farPct float32) {                   │
 │    34        percentages := [float32{centralPct, midPct, farPct}                                        │
 │    35        startX := i.X                                                                              │
 │    36                                                                                             │
 │    37 for _, pct := range percentages {                                                           │
 │    38 // Фон для полосы                                                                           │
 │    39                .DrawRectangle(int32(startX), int32(i.Y), int32(i.BarWidth), int32(i.Height), config      │
 │       .XpBarBackgroundColorRL)                                                                    │
 │    40                                                                                             │
 │    41 // Высота заполнения в зависимости от процента                                              │
 │    42                fillHeight := i.Height * pct                                                              │
 │    43 // Y-координата начала заполнения (снизу вверх)                                             │
 │    44                fillY := i.Y + (i.Height - fillHeight)                                                    │
 │    45                                                                                             │
 │    46 // Цвет меняется в зависимости от истощения                                                 │
 │    47                fillColor := rl.Green                                                                     │
 │    48                if pct < 0.6 {                                                                            │
 │    49 fillColor = rl.Yellow                                                                       │
 │    50                }                                                                                         │
 │    51                if pct < 0.3 {                                                                            │
 │    52 fillColor = rl.Red                                                                          │
 │    53                }                                                                                         │
 │    54                                                                                             │
 │    55 // Рисуем заполнение                                                                        │
 │    56                .DrawRectangle(int32(startX), int32(fillY), int32(i.BarWidth), int32(fillHeight),         │
 │       fillColor)                                                                                  │
 │    57                                                                                             │
 │    58 // Обводка для каждой полосы                                                                │
 │    59                rl.DrawRectangleLinesEx(                                                                  │
 │    60                .NewRectangle(startX, i.Y, i.BarWidth, i.Height),                                         │
 │    61                        config.UIBorderWidth,                                                                    │
 │    62                        config.UIBorderColor,                                                                    │
 │    63                )                                                                                         │
 │    64                                                                                             │
 │    65 // Сдвигаем X для следующей полосы                                                          │
 │    66                startX +i.BarWidth + i.Spacing                                                            │
 │    67        }                                                                                          │
 │    68 }                                                                                           │
 ╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ Отлично. UI-компонент создан. Теперь нужно интегрировать его в игру и обеспечить данными.

  План интеграции:

   1. Изменить генерацию руды для отслеживания жил:
       * Я изменю функцию GenerateOre3D в pkg/hexmap/ore_generation_3d.go, чтобы она возвращала не только
         карту руды, но и информацию о том, какие гексы принадлежат каждой из трех жил.
       * Я изменю GenerateOre в internal/app/ore_generation.go, чтобы она сохраняла эту информацию о жилах.

   2. Хранить и вычислять данные о руде:
       * В internal/app/game.go я добавлю поля для хранения гексов каждой жилы и их начального запаса руды.
       * Я создам там же новую функцию GetOreSectorPercentages(), которая будет вычислять текущий процент
         оставшейся руды для каждой из трех жил.

   3. Интегрировать UI в `game_state`:
       * В internal/state/game_state.go я добавлю новый индикатор.
       * В функции DrawUI я буду вызывать GetOreSectorPercentages() и передавать данные в
         ore_sector_indicator.Draw().

  Начинаю с первого шага: изменяю pkg/hexmap/ore_generation_3d.go, чтобы функция GenerateOre3D возвращала
  информацию о жилах.
 ╭──────────────────────────────────────────────╮
 │ ✔  ReadFile pkg\hexmap\ore_generation_3d.go  │
 ╰──────────────────────────────────────────────╯
✦ Хорошо, я изменю GenerateOre3D, чтобы она возвращала не только карту с рудой, но и информацию о гексах,
  принадлежащих каждой из трех жил. Это позволит мне отслеживать запасы в каждом секторе.

  План:
   1. Изменю сигнатуру функции GenerateOre3D, чтобы она возвращала (map[Hex]float64, [][]Hex).
   2. В конце функции, после фильтрации и очистки, я верну и финальную карту руды (finalEnergyVeins), и
      отфильтрованный срез с гексами каждой жилы (finalVeinAreas).

  Приступаю к модификации pkg/hexmap/ore_generation_3d.go.
 ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
 │ ✔  Edit pkg\hexmap\ore_generation_3d.go: // GenerateOre3D генерирует ру... => // GenerateOre3D генерирует р… │
 │                                                                                                              │
 │     42       return false                                                                                    │
 │     43   }                                                                                                   │
 │     44                                                                                                       │
 │     45 - // GenerateOre3D генерирует руду для 3D-визуализатора.                                              │
 │     46 - // Возвращает карту, где ключ - это гекс, а значение - мощность руды.                               │
 │     47 - // Эта функция является адаптированной версией GenerateOre из основной игры,                        │
 │     48 - // но без зависимостей от ECS и состояния игры.                                                     │
 │     49 - func GenerateOre3D(gameMap *HexMap) map[Hex]float64 {                                               │
 │     45 + // GenerateOre3D генерирует руду и возвращает карту руды и срезы с гексами каждой жилы.             │
 │     46 + func GenerateOre3D(gameMap *HexMap) (map[Hex]float64, [][]Hex) {                                    │
 │     47       allHexes := make([]Hex, 0, len(gameMap.Tiles))                                                  │
 │     48       for hex := range gameMap.Tiles {                                                                │
 │     49           allHexes = append(allHexes, hex)                                                            │
 │    ═════════════════════════════════════════════════════════════════════════════════════════════             │
 │     94       }                                                                                               │
 │     95                                                                                                       │
 │     96       if len(centers) < 3 {                                                                           │
 │    100 -         return make(map[Hex]float64) // Не удалось найти центры, возвращаем пустую                  │
 │        карту                                                                                                 │
 │     97 +         return make(map[Hex]float64), nil // Не удалось найти центры, возвращаем пустые             │
 │        данные                                                                                                │
 │     98       }                                                                                               │
 │     99                                                                                                       │
 │    100       // --- Генерация жил ---                                                                        │
 │    101       veinAreas := make([][]Hex, 3)                                                                   │
 │    102       for i, center := range centers {                                                                │
 │    106 -         if i == 0 { // Центральная ж��ла                                                            │
 │    103 +         if i == 0 { // Центральная жила                                                             │
 │    104               centralVein := []Hex{center}                                                            │
 │    105               neighbors := gameMap.GetNeighbors(center)                                               │
 │    106               rand.Shuffle(len(neighbors), func(i, j int) { neighbors[i], neighbors[j] =              │
 │          neighbors[j], neighbors[i] })                                                                       │
 │    ═════════════════════════════════════════════════════════════════════════════════════════════             │
 │    168           }                                                                                           │
 │    169       }                                                                                               │
 │    170                                                                                                       │
 │    174 -     return finalEnergyVeins                                                                         │
 │    171 +     // Фильтруем veinAreas, чтобы они содержали только гексы, которые попали в                      │
 │        finalEnergyVeins                                                                                      │
 │    172 +     finalVeinAreas := make([][]Hex, 3)                                                              │
 │    173 +     for i, area := range veinAreas {                                                                │
 │    174 +         var finalArea []Hex                                                                         │
 │    175 +         for _, hex := range area {                                                                  │
 │    176 +             if _, exists := finalEnergyVeins[hex]; exists {                                         │
 │    177 +                 finalArea = append(finalArea, hex)                                                  │
 │    178               }                                                                                       │
 │    179 +         }                                                                                           │
 │    180 +         finalVeinAreas[i] = finalArea                                                               │
 │    181 +     }                                                                                               │
 │    182 +                                                                                                     │
 │    183 +     return finalEnergyVeins, finalVeinAreas                                                         │
 │    184 + }                                                                                                   │
 │    185 +                                                                                                     │
 ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
✦ Отлично, ore_generation_3d.go изменен.

  Теперь мне нужно адаптировать internal/app/ore_generation.go, чтобы он использовал новую сигнатуру функции
   и сохранял информацию о жилах.

  План:
   1. Я прочитаю internal/app/ore_generation.go.
   2. Изменю вызов hexmap.GenerateOre3D, чтобы он принимал два возвращаемых значения.
   3. Сохраню полученный срез с гексами жил в структуре Game для дальнейшего использования.

  Начинаю с чтения internal/app/ore_generation.go.