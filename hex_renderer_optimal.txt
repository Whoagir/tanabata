// internal/render/hex_renderer.go
package render

import (
	"go-tower-defense/internal/config"
	"go-tower-defense/pkg/hexmap"
	"sync"

	rl "github.com/gen2brain/raylib-go/raylib"
)

// HexRenderer отвечает за отрисовку гексагональной карты
type HexRenderer struct {
	HexMap       *hexmap.HexMap
	worldPosCache map[hexmap.Hex]rl.Vector3
	cacheMutex    sync.RWMutex
	frustum       *Frustum
	
	// Батчинг для статических объектов
	staticMesh    rl.Mesh
	staticModel   rl.Model
	needsRebuild  bool
}

// Frustum для отсечения невидимых объектов
type Frustum struct {
	camera *rl.Camera3D
	planes [6]rl.Vector4
}

// NewHexRenderer создает новый экземпляр HexRenderer
func NewHexRenderer(hexMap *hexmap.HexMap) *HexRenderer {
	r := &HexRenderer{
		HexMap:        hexMap,
		worldPosCache: make(map[hexmap.Hex]rl.Vector3),
		needsRebuild:  true,
	}
	r.buildStaticMesh()
	return r
}

// SetCamera устанавливает камеру для фрустум куллинга
func (r *HexRenderer) SetCamera(camera *rl.Camera3D) {
	if r.frustum == nil {
		r.frustum = &Frustum{camera: camera}
	} else {
		r.frustum.camera = camera
	}
	r.frustum.updatePlanes()
}

// buildStaticMesh создает единую mesh для всех статических гексов
func (r *HexRenderer) buildStaticMesh() {
	if !r.needsRebuild {
		return
	}
	
	// Подсчитываем количество вершин
	hexCount := len(r.HexMap.Tiles)
	vertexCount := hexCount * 12 // 6 вершин сверху + 6 снизу для каждого гекса
	triangleCount := hexCount * 24 // 12 треугольников на гекс
	
	// Создаем массивы для mesh
	vertices := make([]float32, vertexCount*3)
	normals := make([]float32, vertexCount*3)
	colors := make([]uint8, vertexCount*4)
	
	mapThickness := float32(0.5 * config.CoordScale)
	fillRadius := float32((config.HexSize - 1.5) * config.CoordScale)
	
	idx := 0
	for hex := range r.HexMap.Tiles {
		center := r.getWorldPos(hex)
		
		// Определяем цвет гекса
		var hexColor rl.Color
		switch {
		case hex == r.HexMap.Entry:
			hexColor = config.EntryColorRL
		case hex == r.HexMap.Exit:
			hexColor = config.ExitColorRL
		default:
			isCheckpoint := false
			for _, cp := range r.HexMap.Checkpoints {
				if cp == hex {
					isCheckpoint = true
					break
				}
			}
			if isCheckpoint {
				hexColor = config.CheckpointColorRL
			} else {
				hexColor = config.PassableColorRL
			}
		}
		
		// Генерируем вершины для гекса
		for i := 0; i < 6; i++ {
			angle := float32(i) * rl.Pi * 2 / 6
			x := center.X + fillRadius*rl.Cos(angle)
			z := center.Z + fillRadius*rl.Sin(angle)
			
			// Верхняя вершина
			vertices[idx*3] = x
			vertices[idx*3+1] = center.Y + mapThickness/2
			vertices[idx*3+2] = z
			normals[idx*3+1] = 1
			colors[idx*4] = hexColor.R
			colors[idx*4+1] = hexColor.G
			colors[idx*4+2] = hexColor.B
			colors[idx*4+3] = hexColor.A
			idx++
			
			// Нижняя вершина
			vertices[idx*3] = x
			vertices[idx*3+1] = center.Y - mapThickness/2
			vertices[idx*3+2] = z
			normals[idx*3+1] = -1
			colors[idx*4] = hexColor.R
			colors[idx*4+1] = hexColor.G
			colors[idx*4+2] = hexColor.B
			colors[idx*4+3] = hexColor.A
			idx++
		}
	}
	
	// Если уже есть mesh, освобождаем её
	if r.staticMesh.VertexCount > 0 {
		rl.UnloadMesh(r.staticMesh)
	}
	if r.staticModel.MeshCount > 0 {
		rl.UnloadModel(r.staticModel)
	}
	
	// Создаем новую mesh
	r.staticMesh = rl.Mesh{
		VertexCount:   int32(vertexCount),
		TriangleCount: int32(triangleCount),
		Vertices:      &vertices[0],
		Normals:       &normals[0],
		Colors:        &colors[0],
	}
	
	rl.UploadMesh(&r.staticMesh, false)
	r.staticModel = rl.LoadModelFromMesh(r.staticMesh)
	r.needsRebuild = false
}

// Draw рендерит всю карту одним вызовом
func (r *HexRenderer) Draw() {
	if r.needsRebuild {
		r.buildStaticMesh()
	}
	
	// Рисуем всю статическую геометрию одним вызовом
	if r.staticModel.MeshCount > 0 {
		rl.DrawModel(r.staticModel, rl.Vector3{}, 1.0, rl.White)
	}
	
	// Рисуем только контуры для видимых гексов
	if r.frustum != nil {
		for hex := range r.HexMap.Tiles {
			worldPos := r.getWorldPos(hex)
			if r.frustum.isPointVisible(worldPos) {
				r.drawHexOutline(hex)
			}
		}
	}
}

// getWorldPos возвращает закешированную позицию или вычисляет новую
func (r *HexRenderer) getWorldPos(h hexmap.Hex) rl.Vector3 {
	r.cacheMutex.RLock()
	if pos, ok := r.worldPosCache[h]; ok {
		r.cacheMutex.RUnlock()
		return pos
	}
	r.cacheMutex.RUnlock()
	
	x, y := h.ToPixel(float64(config.HexSize))
	pos := rl.NewVector3(float32(x*config.CoordScale), 0, float32(y*config.CoordScale))
	
	r.cacheMutex.Lock()
	r.worldPosCache[h] = pos
	r.cacheMutex.Unlock()
	
	return pos
}

// drawHexOutline рисует только контур гекса (оптимизированно)
func (r *HexRenderer) drawHexOutline(h hexmap.Hex) {
	center := r.getWorldPos(h)
	mapThickness := float32(0.5 * config.CoordScale)
	outlineRadius := float32(config.HexSize * config.CoordScale)
	
	// Рисуем только верхний контур вместо полного цилиндра
	for i := 0; i < 6; i++ {
		angle1 := float32(i) * rl.Pi * 2 / 6
		angle2 := float32(i+1) * rl.Pi * 2 / 6
		
		x1 := center.X + outlineRadius*rl.Cos(angle1)
		z1 := center.Z + outlineRadius*rl.Sin(angle1)
		x2 := center.X + outlineRadius*rl.Cos(angle2)
		z2 := center.Z + outlineRadius*rl.Sin(angle2)
		
		start := rl.Vector3{X: x1, Y: center.Y + mapThickness/2, Z: z1}
		end := rl.Vector3{X: x2, Y: center.Y + mapThickness/2, Z: z2}
		
		rl.DrawLine3D(start, end, config.StrokeColorRL)
	}
}

// Frustum методы
func (f *Frustum) updatePlanes() {
	if f.camera == nil {
		return
	}
	
	// Упрощенная версия фрустум куллинга
	// В реальности нужно вычислить 6 плоскостей из матрицы проекции
}

func (f *Frustum) isPointVisible(point rl.Vector3) bool {
	if f.camera == nil {
		return true
	}
	
	// Простая проверка по расстоянию
	camPos := f.camera.Position
	dist := rl.Vector3Distance(camPos, point)
	return dist < 1000 * config.CoordScale // Видимость в радиусе 1000 единиц
}

// Cleanup освобождает ресурсы
func (r *HexRenderer) Cleanup() {
	if r.staticMesh.VertexCount > 0 {
		rl.UnloadMesh(r.staticMesh)
	}
	if r.staticModel.MeshCount > 0 {
		rl.UnloadModel(r.staticModel)
	}
}